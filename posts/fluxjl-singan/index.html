<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>matsueushi  | Flux.jlでSinGANを実装する</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1">
	<meta name="generator" content="Hugo 0.73.0" />
	
	
	<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
	

	
	
	<link href="/dist/app.css" rel="stylesheet">
	

	

	
	
<link rel="shortcut icon" href="favicon.ico" type="image/png" />

	

	
	
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-141286537-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

	
	
	



<link rel="stylesheet" href='https://matsueushi.github.io/lib/katex.min.css' integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src='https://matsueushi.github.io/lib/katex.min.js' integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>


<script defer src='https://matsueushi.github.io/lib/contrib/auto-render.min.js' integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
crossorigin="anonymous"
onload='renderMathInElement(document.body);'></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

	
	
</head>

<body class="bg-gray-100 text-gray-700 font-sans">
	<div class="p-6 sm:p-10 md:p-16 flex flex-wrap">
		<header class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-1 md:order-1 max-w-2xl">
			<div
				class="z-50 bg-gray-100 bg-opacity-75 bg-opacity-custom lg:min-w-0.7 max-w-xl md:float-right md:text-right leading-loose tracking-tight md:sticky md:top-0 pt-2">
				
<div>
	<h2>
		<a href="https://matsueushi.github.io/" title="matsueushi" class="heading font-cursive icon">matsueushi</a>
	</h2>
</div>
<h1 class="pt-2">Flux.jlでSinGANを実装する</h1>

<div class="flex flex-wrap justify-end pt-2 "><div class="md:flex-grow-0 font-light">
	

	

	
	
	
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/julia'>Julia</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/deeplearning'>DeepLearning</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/flux'>Flux</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/singan'>SinGAN</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/gan'>GAN</a>
	
	
	
</div><time class="text-eucalyptus-500 md:text-right md:flex-grow font-light pl-4"
		datetime="2020-01-12T01:00:00-05:00">2020-1-12 01:00</time>
</div>

<hr />

			</div>
		</header>
		<main role="main" class="w-full md:w-3/5 xl:w-1/2 max-w-3xl order-2 md:order-2 min-h-70vh pt-2 pb-4">
			

<article>
	<section class="mx-auto content">
		<div class="c-rich-text"><p>今回は、Juliaの機械学習フレームワークFlux.jlでSinGAN(一部)を実装して、1枚のアルバムジャケット画像からアニメーションを作成します。結構長いです。</p>
<p>きっかけは、この紹介記事です。<br>
<a href="https://qiita.com/kuto/items/ff2a30ca939ffdcd3cc1">【SinGAN】たった１枚の画像から多様な画像生成タスクが可能に</a></p>
<p>実は<a href="../fluxjl-dcgan/">DCGANをFlux.jlで実装</a>したあと、MNISTの画像では味気ないので自分でデータセットを作成して画像の自動生成を試みていましたが、
ダブりなく大量の画像を収集してデータセットを整備するのは骨が折れ、今一つの結果しか出なかったのでお蔵入りにしていました。</p>
<p>しかしながら、SinGAN記事に関する読んでみると驚いたことにSinGANではたった1枚の画像から超解像化やアニメーション生成が行え、
ハイスペックのGPUを回さなくても結果が得られるということで実装に挑戦したくなりました。</p>
<p>一部実装を簡略化したので、論文の著者による実装を完全に再現できたわけではないのでご了承ください。
間違っている点・改善すべき点はご指摘頂けると幸いです。</p>
<h2 id="環境">環境</h2>
<p>実行環境はJulia v1.3.0 + Flux.jl v0.10.0 で、GCPのGPU環境(K80)です。</p>
<p>前回と同様、Dockerによる環境構築ですが、JuliaのパッケージもDockerfileに含めてしまっていた前回と違い、
今回はDockerファイルはcudaのベースイメージ+Juliaのシンプルな構成として、Juliaのパッケージ管理はJuliaのプロジェクト機能を用いました。</p>
<p>参考にしたのは主に下記のページです。<br>
<a href="https://qiita.com/cometscome_phys/items/989389db3540ebd9e026">Julia でのパッケージの作り方</a><br>
<a href="https://qiita.com/antimon2/items/5222f4f773bf1944b745">Julia v1.0 でユニットテスト</a></p>
<h2 id="singanのモデルの概略">SinGANのモデルの概略</h2>
<p>理論的な部分の詳細は、論文 <a href="https://arxiv.org/abs/1905.01164">SinGAN: Learning a Generative Model from a Single Natural Image</a> や <a href="https://qiita.com/kuto/items/ff2a30ca939ffdcd3cc1">解説記事</a> に詳しいのでそちらを見ていただきたいのですが、モデルの概要を簡単に説明しておきます。</p>
<p>論文とは別に公開されている <a href="https://tomer.net.technion.ac.il/files/2019/09/SingleImageGan_SM.pdf">Supplementary Material</a> はハイパーパラメーターや画像のパディング、アニメーションのノイズマップの作り方などが掲載されていて参考になります。</p>
<figure>
    <img src="/images/posts/fluxjl-singan_pipeline.png"
         alt="SinGAN’s multi-scale pipeline, retrieved from SinGAN: Learning a Generative Model from a Single Natural Image"/> <figcaption>
            <p>SinGAN’s multi-scale pipeline, retrieved from <a href="https://arxiv.org/abs/1905.01164">SinGAN: Learning a Generative Model from a Single Natural Image</a></p>
        </figcaption>
</figure>

<p>SinGANの学習は、ピラミッド型の構造になっていて、下のステージから順々に学習を行います。
最初は、小さい画像サイズで全体の構造を学習し、ステージを上がっていくごとに画像サイズを拡大していき、微細な構造を学習します。
各ステージでは通常のGANのようにGeneratorとDiscriminatorを並行して学習させていきます。</p>
<p>GeneratorやDiscriminatorのネットワークは、特段難しい構成をしているわけではなく、
Conv(3x3)-BatchNorm-LeakyLeRU(0.2) を5層重ねて最後の活性化関数を Generator だったら <code>tanh</code>,
Discriminator だったら <code>identity</code> に変えたConvolutional netがベースとなります。
Discriminator はこれで完成で、Generator はもう一手間必要です。</p>
<figure>
    <img src="/images/posts/fluxjl-singan_single.png"
         alt="Single Scale Generation, retrieved from SinGAN: Learning a Generative Model from a Single Natural Image"/> <figcaption>
            <p>Single Scale Generation, retrieved from <a href="https://arxiv.org/abs/1905.01164">SinGAN: Learning a Generative Model from a Single Natural Image</a></p>
        </figcaption>
</figure>

<p>Generatorの場合、入力には下層のステップで生成された画像+ノイズを与え、
Convolutional net で生成された結果にもう一度下層の生成画像を加えて出力とします。</p>
<p>論文では Generator \( G_n \) は \(z_n \) をノイズ、\(\tilde{x}_n\) を第 \(n\) 段階の出力画像,
\( \uparrow^r\) をスケール \(r\) 倍の画像拡大とした時に、</p>
<p>$$
\begin{aligned}
\tilde{x}_N &amp;= G_N(z_N), \\
\tilde{x}_n &amp;= G_n(z_n, (\tilde{x}_{n+1})\uparrow^r), n &lt; N
\end{aligned}
$$
で、Fully convolutional net を \(\psi\) とした時に、</p>
<p>$$
\begin{aligned}
G(x, z) = (x)\uparrow^r + \psi(z + (x)\uparrow^r)
\end{aligned}
$$</p>
<p>と言っています。実際は一段階前の画像に0パディングを行う(こともある)のでもう少し複雑になりますがあとで説明します。</p>
<p>損失関数ですが、各ステージで
$$
\begin{aligned}
\min_{G_n} \min_{D_n} ( \mathcal{L}_{\text{adv}}(G_n, D_n) + \alpha \mathcal{L}_{\text{rec}}(G_n) )
\end{aligned}
$$
を考えるのですが、\(\mathcal{L}_{\text{adv}}\) が Adversarial loss と呼ばれている通常の GAN の損失関数で、
計算するときは全てのステージでノイズを加えながら生成します。
\(\mathcal{L}_{\text{rec}}\) は Reconstruction loss で、最初以外は全てゼロとなる特定のノイズ
$$
\begin{aligned}
z^{\text{rec}} = \{z_N^{\text{rec}}, z_{N-1}^{\text{rec}}, \ldots, z_0^{\text{rec}}\} = \{z^*, 0, \ldots, 0 \}
\end{aligned}
$$
を一つ学習を通して固定し、縮小した元画像との二乗誤差
$$
\begin{aligned}
\mathcal{L}_{\text{rec}, N} &amp;= || G_N(z^*) - x_N ||^2, \\
\mathcal{L}_{\text{rec}, n} &amp;= || G_n(0, (\tilde{x}_{n+1}^{\text{rec}})\uparrow^r) - x_n ||^2, n&lt;N
\end{aligned}
$$
を損失関数とするものです。</p>
<p>読んでいて一つ疑問に思ったのが出力データの値域です。
モデルでは、画像データを各数値が \( [-1,1] \) の範囲に収まる <code>Array</code> として表現しているのですが、
Convolutional Netで <code>tanh</code> を適用した段階では \( [-1,1] \) の範囲に収まるものの、
そのあと元の画像を足したらはみ出ることはあり得ます。
ロス関数による制約条件があるため大丈夫なのかもしれませんが……</p>
<h2 id="実装開始">実装開始</h2>
<p>公式実装の <a href="https://github.com/tamarott/SinGAN">tamarott/SinGAN</a> をベースに、他の実装
<a href="https://github.com/FriedRonaldo/SinGAN">FriedRonaldo/SinGAN</a> も時たま参考にしながらやっていきます。</p>
<p>全部説明するのは大変なので、ポイントに絞って説明します。パッケージは先に色々インポートしておきます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">using</span> Adapt
<span style="color:#66d9ef">using</span> BSON<span style="color:#f92672">:</span> <span style="color:#a6e22e">@load</span>, <span style="color:#a6e22e">@save</span>
<span style="color:#66d9ef">using</span> CuArrays
<span style="color:#66d9ef">using</span> Flux
<span style="color:#66d9ef">using</span> Flux<span style="color:#f92672">:</span> mse, pullback, glorot_normal
<span style="color:#66d9ef">using</span> Flux<span style="color:#f92672">.</span>Optimise<span style="color:#f92672">:</span> update!
<span style="color:#66d9ef">using</span> JSON
<span style="color:#66d9ef">using</span> OrderedCollections
<span style="color:#66d9ef">using</span> Random
<span style="color:#66d9ef">using</span> Statistics
</code></pre></div><h3 id="配列の0乱数埋め">配列の0、乱数埋め</h3>
<p>役立つ関数をいくつか定義しておきます。</p>
<p>Convolutional Layerに対するFlux.jlの入力データは WHCN の順の array であり、
今回はカラー画像を使うのでチャンネル数は3(アルファチャンネルがないものを今回は使います), バッチサイズは1なので、画像サイズから array のサイズを計算する関数 <code>expand_dim</code> を下のように定義します。</p>
<p>あとは与えた配列と同じ型 (CPU 環境だったら <code>Array</code>, GPU 環境だと <code>CuArray</code>) で0や乱数で埋めた配列が欲しくなることがあるので、そのための関数も用意します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">expand_dim(dim<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> (dim<span style="color:#f92672">...</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>)
zeros_like(T<span style="color:#f92672">::</span><span style="color:#66d9ef">Type</span>, dims<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> fill!(similar(T, dims<span style="color:#f92672">...</span>), <span style="color:#ae81ff">0f0</span>)
zeros_like(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, dims<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> fill!(similar(xs, dims<span style="color:#f92672">...</span>), <span style="color:#ae81ff">0f0</span>)
randn_like(T<span style="color:#f92672">::</span><span style="color:#66d9ef">Type</span>, dims<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> randn!(similar(T, dims<span style="color:#f92672">...</span>))
randn_like(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, dims<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> randn!(similar(xs, dims<span style="color:#f92672">...</span>))
</code></pre></div><p>Flux.jl では <code>gpu</code> という関数が定義されていて、この関数は CUDA 環境が有効な時に限り オブジェクト (<code>Array</code> など) を CUDA 用のオブジェクト (<code>CuArray</code> など) にコンバートします。(CUDA 環境が有効でない時は何もしません)。逆に <code>Array</code> に変換を行う <code>cpu</code> という関数も存在します。</p>
<p>普通に <code>zeros</code> や <code>randn</code> を使って <code>gpu</code> で変換してもいいのですが、
Juliaだと関数は型安定である方がいいと言われているので、出力の型が環境に応じて変化する <code>gpu</code> を毎回使うのを防ぐために <code>zeros_like</code> と <code>randn_like</code> を定義しました。</p>
<p>気になって変換方法について色々試してみたのですが、やはり <code>similar!</code> を使うのが良いのではないかと思います。 <a href="https://gist.github.com/matsueushi/be3071f6b6be040dd7ae9e51cf74b1e5">https://gist.github.com/matsueushi/be3071f6b6be040dd7ae9e51cf74b1e5</a></p>
<h3 id="画像サイズの計算">画像サイズの計算</h3>
<p>最下層の画像のサイズ <code>min_size</code> からスタートして、サイズを縦横 <code>scale</code> 倍することを繰り返して最終的なサイズ <code>image_size</code> に拡大していく関数を作ります。
100層も学習することはないと思うので下のような形になっています。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> size_pyramid(scale, min_size, image_size)
    current_size <span style="color:#f92672">=</span> min_size 
    pyramid <span style="color:#f92672">=</span> <span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}()
    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">100</span>
        push!(pyramid, current_size)
        current_size <span style="color:#f92672">==</span> image_size <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">break</span>
        current_size <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">@</span><span style="color:#f92672">.</span> floor(<span style="color:#66d9ef">Int64</span>, min_size <span style="color:#f92672">*</span> scale<span style="color:#f92672">^</span>i)
        current_size <span style="color:#f92672">=</span> min<span style="color:#f92672">.</span>(current_size, image_size)
    <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">return</span> pyramid
<span style="color:#66d9ef">end</span>
</code></pre></div><p>中間の Conv 層のチャンネル数は 32 からスタートしてピラミッドを 4 階上がるごとに 2 倍になりますが、128でキャップをかけておきます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">channel_pyramid(n_stage) <span style="color:#f92672">=</span> min<span style="color:#f92672">.</span>(map(s<span style="color:#f92672">-&gt;</span><span style="color:#ae81ff">32</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">^</span>(floor(<span style="color:#66d9ef">Int64</span>, s <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>)), <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n_stage), <span style="color:#ae81ff">128</span>)
</code></pre></div><h3 id="画像の拡大パディング">画像の拡大、パディング</h3>
<p>画像を <code>image_shape</code> の大きさに拡大したあと、周囲を <code>padded_shape</code> の大きさになるまで0で埋める関数を作ります。</p>
<p>Supplimental Material の &ldquo;Boundary conditions and the effect of padding&rdquo; を見ると
Conv 層における0埋めにより画像の四隅の多様性が失われるが、Generator に入力するノイズの周辺をノイズでパディングする
(つまり、ノイズ画像の方を大きくする)と軽減されるということなので、今回アニメーションをさせることを考えて0埋めをすることにしました。</p>
<p>そのため
$$
\begin{aligned}
G(x, z) = (x)\uparrow^r + \psi(z + (x)\uparrow^r)
\end{aligned}
$$
は少し修正が必要になります。\(z\) は \((x)\uparrow^r\) よりも 四方が幅 \(d\) だけ大きいように毎回取るようにして、
\(\langle \rangle_d\) を幅 \(d\) の0パディング,  \(\rangle \langle_d\) を幅 \(d\) のトリミングとすると、実際にやることは</p>
<p>$$
\begin{aligned}
G(x, z) &amp;= \rangle(\bar{x} + \psi(z + \bar{x}))\langle_d, \\
\bar{x} &amp;= \langle(x)\uparrow^r\rangle_d
\end{aligned}
$$
です。定義するのは \(\langle(\cdot)\uparrow^r\rangle_d\) の部分です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> resize_and_padding(x<span style="color:#f92672">::</span><span style="color:#66d9ef">Array</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}, 
            image_shape<span style="color:#f92672">::</span><span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}, padded_shape<span style="color:#f92672">::</span><span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>})
    <span style="color:#75715e"># println(size(x), image_shape, padded_shape)</span>
    x_large <span style="color:#f92672">=</span> imresize(view(x, <span style="color:#f92672">:</span>, <span style="color:#f92672">:</span>, <span style="color:#f92672">:</span>, <span style="color:#ae81ff">1</span>), image_shape<span style="color:#f92672">...</span>)
    xx <span style="color:#f92672">=</span> zeros(<span style="color:#66d9ef">Float32</span>, expand_dim(padded_shape<span style="color:#f92672">...</span>))
    pad1, pad2 <span style="color:#f92672">=</span> (<span style="color:#960050;background-color:#1e0010">@</span><span style="color:#f92672">.</span> (padded_shape <span style="color:#f92672">-</span> image_shape) <span style="color:#f92672">÷</span> <span style="color:#ae81ff">2</span>)[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">2</span>]
    xx[<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad1<span style="color:#f92672">:</span>image_shape[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> pad1, <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad2<span style="color:#f92672">:</span>image_shape[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> pad2, <span style="color:#f92672">:</span> , <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> x_large
    <span style="color:#66d9ef">return</span> xx
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> resize_and_padding(x<span style="color:#f92672">::</span>CuArray{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}, 
            image_shape<span style="color:#f92672">::</span><span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}, padded_shape<span style="color:#f92672">::</span><span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>})
    <span style="color:#66d9ef">return</span> cu(resize_and_padding(adapt(<span style="color:#66d9ef">Array</span>{<span style="color:#66d9ef">Float32</span>}, x), image_shape, padded_shape))
<span style="color:#66d9ef">end</span>
</code></pre></div><p>関数を <code>Array</code> と <code>CuArray</code> で分けているのは、 画像を拡大するImages.jlの <code>imresize</code> を使うと <code>GPU arrays</code> のスカラー操作が極めて遅いと警告が出るためです。
<a href="https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/indexing.jl#L16">https://github.com/JuliaGPU/GPUArrays.jl/blob/master/src/indexing.jl#L16</a>
<code>CuArray</code> の場合は一旦 <code>Array</code> に変換して拡大とパディングを行い、 <code>CuArray</code> に戻していますが効果のほどは不明です。</p>
<p>あとあと各ステージの画像サイズに合わせて元画像を縮小した \( x_n \) が必要になります。これを一気に作れる関数を用意します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> build_image_pyramid(img<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, image_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}, noise_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}})
    <span style="color:#66d9ef">return</span> map((is, ns)<span style="color:#f92672">-&gt;</span>resize_and_padding(img, is, ns), image_shapes, noise_shapes)
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="ノイズの作成">ノイズの作成</h3>
<p>Adversarial loss と Reconstuction loss を計算する時に使うノイズ \(z^{\text{adv}}, z^{\text{rec}}\) をそれぞれ計算する関数
<code>build_noise_pyramid</code> と <code>build_rec_pyramid</code> を生成します。</p>
<p>学習の状況に応じてステージごとにノイズの分散は変化するので、調節が行えるようにします。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> build_zero_pyramid(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}})
    <span style="color:#66d9ef">return</span> map(s<span style="color:#f92672">-&gt;</span>zeros_like(xs, expand_dim(s<span style="color:#f92672">...</span>)), shapes)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> build_noise_pyramid(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}, amplifiers<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Float32</span>})
    <span style="color:#66d9ef">return</span> map((s, a)<span style="color:#f92672">-&gt;</span>a <span style="color:#f92672">*</span> randn_like(xs, expand_dim(s<span style="color:#f92672">...</span>)), shapes, amplifiers)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> build_rec_pyramid(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}, amplifier<span style="color:#f92672">::</span><span style="color:#66d9ef">Float32</span>)
    v <span style="color:#f92672">=</span> build_zero_pyramid(xs, shapes)
    randn!(v[<span style="color:#ae81ff">1</span>])
    v[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*=</span> amplifier
    <span style="color:#66d9ef">return</span> v
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="convolutional-block">Convolutional block</h3>
<p>Discriminator, Generator の準備として、Convolutional block \(\psi\) から作っていきます。</p>
<p>このような感じで Discriminator, Generator のどちらも使える <code>build_layers</code> を定義しておきます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#75715e"># Re-define leakyrelu function</span>
<span style="color:#75715e"># https://github.com/FluxML/Flux.jl/issues/963</span>
myleakyrelu(x<span style="color:#f92672">::</span><span style="color:#66d9ef">Real</span>, a <span style="color:#f92672">=</span> oftype(x <span style="color:#f92672">/</span> one(x), <span style="color:#ae81ff">0.01</span>)) <span style="color:#f92672">=</span> max(a <span style="color:#f92672">*</span> x, x <span style="color:#f92672">/</span> one(x))

conv_block(<span style="color:#66d9ef">in</span>, out) <span style="color:#f92672">=</span> [
        Conv((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), <span style="color:#66d9ef">in</span> <span style="color:#f92672">=&gt;</span> out; init <span style="color:#f92672">=</span> glorot_normal, pad <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)),
        BatchNorm(out),
        x<span style="color:#f92672">-&gt;</span>myleakyrelu<span style="color:#f92672">.</span>(x, <span style="color:#ae81ff">0.2f0</span>)
    ]

<span style="color:#66d9ef">function</span> build_layers(n_layers, in_chs, conv_chs, out_chs, σ)
    layers <span style="color:#f92672">=</span> conv_block(in_chs, conv_chs)
    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>n_layers <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>
        push!(layers, conv_block(conv_chs, conv_chs)<span style="color:#f92672">...</span>)
    <span style="color:#66d9ef">end</span>
    tail_layer <span style="color:#f92672">=</span> Conv((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), conv_chs <span style="color:#f92672">=&gt;</span> out_chs, σ;
        init <span style="color:#f92672">=</span> glorot_normal, pad <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>))
    push!(layers, tail_layer)
    <span style="color:#66d9ef">return</span> Chain(layers<span style="color:#f92672">...</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>leakyrelu</code> は NNlib.jl で定義されているので Flux.jl で使えますが、
<code>Float32</code> の数値における (Zygote.jlの) 微分が <code>Float64</code> になってしまうので自分で定義します。<br>
<a href="https://github.com/FluxML/Flux.jl/issues/963">https://github.com/FluxML/Flux.jl/issues/963</a><br>
<a href="https://github.com/FluxML/Flux.jl/issues/979">https://github.com/FluxML/Flux.jl/issues/979</a></p>
<p>NNlib.jlに投げたこのプルリクがマージされたら定義し直す必要がなくなる予定です。(CuArrays.jl も修正する必要があるかもしれませんが……)
<a href="https://github.com/FluxML/NNlib.jl/pull/149">https://github.com/FluxML/NNlib.jl/pull/149</a></p>
<h3 id="discriminator-generator">Discriminator, Generator</h3>
<p>いよいよ Discriminator, Generator の定義です。
簡単な Discriminator から作ります。DiscriminatorPyramid に関しては、単に Discriminator を複数個集めて来ただけです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    DiscriminatorPyramid
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">struct</span> DiscriminatorPyramid{T <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">Tuple</span>}
    chains<span style="color:#f92672">::</span>T
    DiscriminatorPyramid(xs<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> new{typeof(xs)}(xs)
<span style="color:#66d9ef">end</span>

build_single_discriminator(n_layers, conv_chs) <span style="color:#f92672">=</span> build_layers(n_layers, <span style="color:#ae81ff">3</span>, conv_chs, <span style="color:#ae81ff">1</span>, identity)

<span style="color:#66d9ef">function</span> DiscriminatorPyramid(n_stage<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>, n_layers<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>)
    ds <span style="color:#f92672">=</span> build_single_discriminator<span style="color:#f92672">.</span>(n_layers, channel_pyramid(n_stage))
    <span style="color:#66d9ef">return</span> DiscriminatorPyramid(gpu<span style="color:#f92672">.</span>(ds)<span style="color:#f92672">...</span>)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> DiscriminatorPyramid(image_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}, n_layers<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>)
    DiscriminatorPyramid(Base<span style="color:#f92672">.</span>length(image_shapes), n_layers)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> Base<span style="color:#f92672">.</span>show(io<span style="color:#f92672">::</span><span style="color:#66d9ef">IO</span>, d<span style="color:#f92672">::</span>DiscriminatorPyramid)
    print(io, <span style="color:#e6db74">&#34;DiscriminatorPyramid(&#34;</span>)
    join(io, d<span style="color:#f92672">.</span>chains, <span style="color:#e6db74">&#34;, </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
    print(io, <span style="color:#e6db74">&#34;)&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>ノイズ画像を足してレイヤーに通し、出力結果にオリジナルの画像を加えて周囲をトリミングする <code>NoiseConnection</code> (名前は適当)を作ります。
$$
\begin{aligned}
G(x, z) &amp;= \rangle(\bar{x} + \psi(z + \bar{x}))\langle_d, \\
\bar{x} &amp;= \langle(x)\uparrow^r\rangle_d
\end{aligned}
$$
上の式で言えば
$$
\begin{aligned}
N(\bar{x}, z) &amp;= \rangle(\bar{x} + \psi(z + \bar{x}))\langle_d
\end{aligned}
$$</p>
<p>を計算するレイヤーです。<code>pad</code> は周囲でノイズパディングを行うサイズ \(d\) です。
<code>basic.jl</code> の <code>SkipConnection</code> の実装を参考にしました。
<a href="https://github.com/FluxML/Flux.jl/blob/e92da0cf850a982c425b83c92d6274174e52b02c/src/layers/basic.jl#L197">https://github.com/FluxML/Flux.jl/blob/e92da0cf850a982c425b83c92d6274174e52b02c/src/layers/basic.jl#L197</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    NoiseConnection
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">struct</span> NoiseConnection
    layers
    pad<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>
<span style="color:#66d9ef">end</span>

<span style="color:#a6e22e">@Flux</span><span style="color:#f92672">.</span>functor NoiseConnection

<span style="color:#66d9ef">function</span> (nc<span style="color:#f92672">::</span>NoiseConnection)(prev<span style="color:#f92672">::</span>T, noise<span style="color:#f92672">::</span>T) where {T <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">AbstractArray</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}}
    pad <span style="color:#f92672">=</span> nc<span style="color:#f92672">.</span>pad
    raw_output <span style="color:#f92672">=</span> nc<span style="color:#f92672">.</span>layers(noise <span style="color:#f92672">+</span> prev)<span style="color:#f92672">::</span>T <span style="color:#f92672">+</span> prev
    <span style="color:#66d9ef">return</span> raw_output[<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad<span style="color:#f92672">:</span><span style="color:#66d9ef">end</span> <span style="color:#f92672">-</span> pad, <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad<span style="color:#f92672">:</span><span style="color:#66d9ef">end</span> <span style="color:#f92672">-</span> pad, <span style="color:#f92672">:</span>, <span style="color:#f92672">:</span>]
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> Base<span style="color:#f92672">.</span>show(io<span style="color:#f92672">::</span><span style="color:#66d9ef">IO</span>, nc<span style="color:#f92672">::</span>NoiseConnection)
    print(io, <span style="color:#e6db74">&#34;NoiseConnection(&#34;</span>, nc<span style="color:#f92672">.</span>layers, <span style="color:#e6db74">&#34;, &#34;</span>, nc<span style="color:#f92672">.</span>pad, <span style="color:#e6db74">&#34;)&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>いよいよ GeneratorPyramid の定義です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    GeneratorPyramid
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">struct</span> GeneratorPyramid{T <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">Tuple</span>}
    image_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}
    noise_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}
    pad<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>
    chains<span style="color:#f92672">::</span>T
    GeneratorPyramid(image_shapes, noise_shapes, pad, xs<span style="color:#f92672">...</span>) <span style="color:#f92672">=</span> new{typeof(xs)}(image_shapes, noise_shapes, pad, xs)
<span style="color:#66d9ef">end</span>

build_single_gen_layers(n_layers, conv_chs) <span style="color:#f92672">=</span> build_layers(n_layers, <span style="color:#ae81ff">3</span>, conv_chs, <span style="color:#ae81ff">3</span>, tanh)
build_single_generator(n_layers, conv_chs, pad) <span style="color:#f92672">=</span> NoiseConnection(build_single_gen_layers(n_layers, conv_chs), pad)

<span style="color:#66d9ef">function</span> GeneratorPyramid(image_shapes<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{<span style="color:#66d9ef">Tuple</span>{<span style="color:#66d9ef">Int64</span>,<span style="color:#66d9ef">Int64</span>}}, n_layers<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>, pad<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>)
    n_stage <span style="color:#f92672">=</span> Base<span style="color:#f92672">.</span>length(image_shapes)
    <span style="color:#75715e"># receptive field = 11, floor(11/2) = 5</span>
    noise_shapes <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> pad <span style="color:#f92672">.+</span> s <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> image_shapes]
    ds <span style="color:#f92672">=</span> build_single_generator<span style="color:#f92672">.</span>(n_layers, channel_pyramid(n_stage), pad)
    <span style="color:#66d9ef">return</span> GeneratorPyramid(image_shapes, noise_shapes, pad, gpu<span style="color:#f92672">.</span>(ds)<span style="color:#f92672">...</span>)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> Base<span style="color:#f92672">.</span>show(io<span style="color:#f92672">::</span><span style="color:#66d9ef">IO</span>, d<span style="color:#f92672">::</span>GeneratorPyramid)
    print(io, <span style="color:#e6db74">&#34;GeneratorPyramid(&#34;</span>)
    print(io, d<span style="color:#f92672">.</span>image_shapes, <span style="color:#e6db74">&#34;, &#34;</span>)
    print(io, d<span style="color:#f92672">.</span>noise_shapes, <span style="color:#e6db74">&#34;, &#34;</span>)
    println(io, d<span style="color:#f92672">.</span>pad, <span style="color:#e6db74">&#34;, &#34;</span>)
    join(io, d<span style="color:#f92672">.</span>chains, <span style="color:#e6db74">&#34;, </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
    print(io, <span style="color:#e6db74">&#34;)&#34;</span>)
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> (genp<span style="color:#f92672">::</span>GeneratorPyramid)(xs<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractVector</span>{T}, st<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>, resize<span style="color:#f92672">::</span><span style="color:#66d9ef">Bool</span>) where {T <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">AbstractArray</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}}
    <span style="color:#66d9ef">if</span> st <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
        zeros_shape <span style="color:#f92672">=</span> resize <span style="color:#f92672">?</span> first(genp<span style="color:#f92672">.</span>noise_shapes) <span style="color:#f92672">:</span> first(genp<span style="color:#f92672">.</span>image_shapes)
        <span style="color:#66d9ef">return</span> zeros_like(T, expand_dim(zeros_shape<span style="color:#f92672">...</span>))
    <span style="color:#66d9ef">end</span>
    prev <span style="color:#f92672">=</span> genp(xs, st <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>)
    out <span style="color:#f92672">=</span> genp<span style="color:#f92672">.</span>chains[st](prev, xs[st])
    <span style="color:#66d9ef">return</span> resize <span style="color:#f92672">?</span> resize_and_padding(out, genp<span style="color:#f92672">.</span>image_shapes[st <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], genp<span style="color:#f92672">.</span>noise_shapes[st <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">:</span> out
<span style="color:#66d9ef">end</span>
</code></pre></div><p>最後の関数が画像を生成する関数で、<code>xs</code> が与えるノイズ、<code>st</code> が到達したいステージ、<code>resize</code> が生成した後に拡大したいかどうかです。
ステージの添字の数え方は論文とは上下が逆で下から上の順に大きくなっているので注意です。</p>
<h3 id="損失関数">損失関数</h3>
<p>次に損失関数を定義します。SinGAN のオリジナルの実装では GAN には WGAN-GP を使っているのですが、残念なが自分のスキルでは Gradientを損失条件の中に入れられなかった
(損失関数の中にGradientの計算関数を入れると、損失関数の微分が取れなかった) ので、泣く泣く LSGAN に置き換えています。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> discriminator_loss(d_real<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, d_g_fake_adv<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>)
    real_loss <span style="color:#f92672">=</span> mse(<span style="color:#ae81ff">1f0</span>, mean(d_real; dims <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)))
    fake_loss <span style="color:#f92672">=</span> mse(<span style="color:#ae81ff">0f0</span>, mean(d_g_fake_adv; dims <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)))
    <span style="color:#66d9ef">return</span> real_loss <span style="color:#f92672">+</span> fake_loss
<span style="color:#66d9ef">end</span>

generator_adv_loss(d_g_fake_adv<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>) <span style="color:#f92672">=</span> mse(<span style="color:#ae81ff">1f0</span>, mean(d_g_fake_adv; dims <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)))

generator_rec_loss(real_img<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>, g_fake_rec<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>) <span style="color:#f92672">=</span> mse(real_img, g_fake_rec)
</code></pre></div><p>いちいち0や1をベクトルに直す必要はありません。シンプルに書けていいですね。</p>
<h3 id="discriminator-generator-の更新">Discriminator, Generator の更新</h3>
<p>損失関数の値を計算し、Discriminator, Generator のパラメーターに関する微分を取ってパラメーターを更新する関数を書きます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> update_discriminator!(opt, dscr, real_img, g_fake_adv)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    ps <span style="color:#f92672">=</span> params(dscr)
    grad <span style="color:#f92672">=</span> gradient(ps) <span style="color:#66d9ef">do</span>
        discriminator_loss(dscr(real_img), dscr(g_fake_adv))
    <span style="color:#66d9ef">end</span>
    update!(opt, ps, grad)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> update_generator!(opt, dscr, gen, real_img, prev_rec, prev_adv, noise_rec, noise_adv, alpha)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    ps <span style="color:#f92672">=</span> params(gen)
    grad <span style="color:#f92672">=</span> gradient(ps) <span style="color:#66d9ef">do</span>
        g_fake_rec <span style="color:#f92672">=</span> gen(prev_rec, noise_rec)
        d_g_fake_adv <span style="color:#f92672">=</span> dscr(gen(prev_adv, noise_adv))
        generator_adv_loss(d_g_fake_adv) <span style="color:#f92672">+</span> alpha <span style="color:#f92672">*</span> generator_rec_loss(real_img, g_fake_rec)
    <span style="color:#66d9ef">end</span>
    update!(opt, ps, grad)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>ここで、</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">grad <span style="color:#f92672">=</span> gradient(ps) <span style="color:#66d9ef">do</span>
    discriminator_loss(dscr(real_img), dscr(g_fake_adv))
<span style="color:#66d9ef">end</span>
</code></pre></div><p>この部分はこれと一緒です。(<a href="https://docs.julialang.org/en/v1/manual/functions/index.html#man-anonymous-functions-1">https://docs.julialang.org/en/v1/manual/functions/index.html#man-anonymous-functions-1</a>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">grad <span style="color:#f92672">=</span> gradient(() <span style="color:#f92672">-&gt;</span> discriminator_loss(dscr(real_img), dscr(g_fake_adv)), ps)
</code></pre></div><p><code>gradient</code> の代わりに <code>pullback</code> を使うと微分と同時に関数の値も取得できます。(<a href="https://fluxml.ai/Zygote.jl/latest/adjoints/#Pullbacks-1">https://fluxml.ai/Zygote.jl/latest/adjoints/#Pullbacks-1</a>)</p>
<p>パラメーターの更新後に損失関数の値を返したい場合、例えばこのように書けばOKです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> update_discriminator!(opt, dscr, real_img, g_fake_adv)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    ps <span style="color:#f92672">=</span> params(dscr)
    loss, back <span style="color:#f92672">=</span> pullback(ps) <span style="color:#66d9ef">do</span>
        discriminator_loss(dscr(real_img), dscr(g_fake_adv))
    <span style="color:#66d9ef">end</span>
    grad <span style="color:#f92672">=</span> back(Zygote<span style="color:#f92672">.</span>sensitivity(loss))
    update!(opt, ps, grad)
    <span style="color:#a6e22e">@eval</span> Flux<span style="color:#f92672">.</span>istraining() <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
    <span style="color:#66d9ef">return</span> loss
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="学習">学習</h3>
<p>1エポックの学習は次のようになります。
改めて損失関数の値を計算しているので少し無駄になっている気もしますが気にしないでおきます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> train_epoch!(opt_dscr, opt_gen, st, loop_dscr, loop_gen,
        dscr, genp, prev_rec, noise_rec, real_img, amplifiers, alpha)

    <span style="color:#75715e"># discriminator</span>
    foreach(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>loop_dscr) <span style="color:#66d9ef">do</span> _
        noise_adv <span style="color:#f92672">=</span> build_noise_pyramid(prev_rec, genp<span style="color:#f92672">.</span>noise_shapes[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>st], amplifiers)
        g_fake_adv <span style="color:#f92672">=</span> genp(noise_adv, st, <span style="color:#66d9ef">false</span>)
        update_discriminator!(opt_dscr, dscr, real_img, g_fake_adv)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e"># generator</span>
    foreach(<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>loop_gen) <span style="color:#66d9ef">do</span> _
        noise_adv <span style="color:#f92672">=</span> build_noise_pyramid(prev_rec, genp<span style="color:#f92672">.</span>noise_shapes[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>st], amplifiers)
        prev_adv <span style="color:#f92672">=</span> genp(noise_adv, st <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>)
        update_generator!(opt_gen, dscr, genp<span style="color:#f92672">.</span>chains[st], real_img, prev_rec, prev_adv, noise_rec, last(noise_adv), alpha)
    <span style="color:#66d9ef">end</span>

    noise_adv <span style="color:#f92672">=</span> build_noise_pyramid(prev_rec, genp<span style="color:#f92672">.</span>noise_shapes[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>st], amplifiers)
    g_fake_adv <span style="color:#f92672">=</span> genp(noise_adv, st, <span style="color:#66d9ef">false</span>)
    loss_dscr <span style="color:#f92672">=</span> discriminator_loss(dscr(real_img), dscr(g_fake_adv))
    d_g_fake_adv <span style="color:#f92672">=</span> dscr(g_fake_adv)
    loss_gen_adv <span style="color:#f92672">=</span> generator_adv_loss(d_g_fake_adv)
    g_fake_rec <span style="color:#f92672">=</span> genp<span style="color:#f92672">.</span>chains[st](prev_rec, noise_rec)
    loss_gen_rec <span style="color:#f92672">=</span> generator_rec_loss(real_img, g_fake_rec) 

    <span style="color:#66d9ef">return</span> loss_dscr, loss_gen_adv, loss_gen_rec
<span style="color:#66d9ef">end</span>
</code></pre></div><p>ハイパーパラメーターを入れておく箱を用意して、</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">struct</span> HyperParams
    scale<span style="color:#f92672">::</span><span style="color:#66d9ef">Float64</span>                  <span style="color:#75715e"># progression scale, &gt; 1</span>
    min_size_x<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>               <span style="color:#75715e"># minimal image width</span>
    min_size_y<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>               <span style="color:#75715e"># minimal image height</span>
    img_size_x<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>               <span style="color:#75715e"># output image width</span>
    img_size_y<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>               <span style="color:#75715e"># output image height</span>
    n_layers<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>                 <span style="color:#75715e"># number of conv layers</span>
    max_epoch<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>                <span style="color:#75715e"># training epochs</span>
    reduce_lr_epoch<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>          <span style="color:#75715e"># reduce learining rate after training `redule_lr_epoch` epochs</span>
    save_image_every_epoch<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>   <span style="color:#75715e"># save generated image every `save_image_every_epoch` epoch</span>
    save_loss_every_epoch<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>    <span style="color:#75715e"># save loss every `save_loss_every_epoch` epoch</span>
    loop_dscr<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>                <span style="color:#75715e"># training steps par descriminator training epoch</span>
    loop_gen<span style="color:#f92672">::</span><span style="color:#66d9ef">Int64</span>                 <span style="color:#75715e"># training steps par generator training epoch</span>
    lr_dscr<span style="color:#f92672">::</span><span style="color:#66d9ef">Float64</span>                <span style="color:#75715e"># discriminator learining rate</span>
    lr_gen<span style="color:#f92672">::</span><span style="color:#66d9ef">Float64</span>                 <span style="color:#75715e"># generator learning rate</span>
    alpha<span style="color:#f92672">::</span><span style="color:#66d9ef">Float32</span>                  <span style="color:#75715e"># rec loss coefficient</span>
    amplifier_init<span style="color:#f92672">::</span><span style="color:#66d9ef">Float32</span>         <span style="color:#75715e"># noise amplifier</span>
    HyperParams() <span style="color:#f92672">=</span> new(<span style="color:#ae81ff">4</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2000</span>, <span style="color:#ae81ff">1600</span>, <span style="color:#ae81ff">500</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5e-4</span>, <span style="color:#ae81ff">5e-4</span>, <span style="color:#ae81ff">50f0</span>, <span style="color:#ae81ff">1f0</span>)
<span style="color:#66d9ef">end</span>

show_dict(hp<span style="color:#f92672">::</span>HyperParams) <span style="color:#f92672">=</span> OrderedDict(string(nm) <span style="color:#f92672">=&gt;</span> getfield(hp, nm) <span style="color:#66d9ef">for</span> nm <span style="color:#66d9ef">in</span> fieldnames(HyperParams))
image_shapes(hp<span style="color:#f92672">::</span>HyperParams) <span style="color:#f92672">=</span> size_pyramid(hp<span style="color:#f92672">.</span>scale, (hp<span style="color:#f92672">.</span>min_size_x, hp<span style="color:#f92672">.</span>min_size_y), (hp<span style="color:#f92672">.</span>img_size_x, hp<span style="color:#f92672">.</span>img_size_y))

<span style="color:#66d9ef">function</span> setup_models(hp<span style="color:#f92672">::</span>HyperParams)
    img_shapes <span style="color:#f92672">=</span> image_shapes(hp)
    dscrp <span style="color:#f92672">=</span> DiscriminatorPyramid(img_shapes, hp<span style="color:#f92672">.</span>n_layers) <span style="color:#f92672">|&gt;</span> gpu
    genp <span style="color:#f92672">=</span> GeneratorPyramid(img_shapes, hp<span style="color:#f92672">.</span>n_layers) <span style="color:#f92672">|&gt;</span> gpu
    <span style="color:#66d9ef">return</span> dscrp, genp
<span style="color:#66d9ef">end</span>
</code></pre></div><p>ようやく最終的な <code>train</code> 関数の完成です。(画像を出力するところなどは省いています)。
<code>estimate_noise_amplifier</code> は、一段階前の画像と元画像からノイズの分散を調節する関数です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#66d9ef">function</span> estimate_noise_amplifier(prev_rec<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}, real_img<span style="color:#f92672">::</span><span style="color:#66d9ef">AbstractArray</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>},
        pad<span style="color:#f92672">::</span><span style="color:#66d9ef">Integer</span>, amplifier_init<span style="color:#f92672">::</span><span style="color:#66d9ef">Float32</span>)
    prev_rec_crop <span style="color:#f92672">=</span> <span style="color:#a6e22e">@view</span> prev_rec[<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad<span style="color:#f92672">:</span><span style="color:#66d9ef">end</span> <span style="color:#f92672">-</span> pad, <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> pad<span style="color:#f92672">:</span><span style="color:#66d9ef">end</span> <span style="color:#f92672">-</span> pad, <span style="color:#f92672">:</span>, <span style="color:#f92672">:</span>]
    rmse <span style="color:#f92672">=</span> sqrt(mse(real_img, prev_rec_crop))
    <span style="color:#66d9ef">return</span> rmse <span style="color:#f92672">*</span> amplifier_init
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> train!(dscrp<span style="color:#f92672">::</span>DiscriminatorPyramid, genp<span style="color:#f92672">::</span>GeneratorPyramid, 
        real_img_p<span style="color:#f92672">::</span><span style="color:#66d9ef">Vector</span>{T}, hp<span style="color:#f92672">::</span>HyperParams) where {T <span style="color:#f92672">&lt;:</span> <span style="color:#66d9ef">AbstractArray</span>{<span style="color:#66d9ef">Float32</span>,<span style="color:#ae81ff">4</span>}}
    stages <span style="color:#f92672">=</span> Base<span style="color:#f92672">.</span>length(genp<span style="color:#f92672">.</span>image_shapes)

    amplifiers <span style="color:#f92672">=</span> <span style="color:#66d9ef">Float32</span>[]

    <span style="color:#75715e"># fixed noise for rec</span>
    fixed_noise_rec <span style="color:#f92672">=</span> build_rec_pyramid(first(real_img_p), genp<span style="color:#f92672">.</span>noise_shapes, <span style="color:#ae81ff">1f0</span>)
    fixed_noise_adv <span style="color:#f92672">=</span> similar(fixed_noise_rec)
    
    <span style="color:#66d9ef">for</span> st <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>stages
        <span style="color:#a6e22e">@info</span> <span style="color:#e6db74">&#34;Step </span><span style="color:#e6db74">$</span>(st)<span style="color:#e6db74">&#34;</span>
        <span style="color:#75715e"># reset optimizer</span>
        opt_dscr <span style="color:#f92672">=</span> ADAM(hp<span style="color:#f92672">.</span>lr_dscr, (<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.999</span>))
        opt_gen <span style="color:#f92672">=</span> ADAM(hp<span style="color:#f92672">.</span>lr_gen, (<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.999</span>))

        <span style="color:#75715e"># calculate noise amplifier</span>
        prev_rec <span style="color:#f92672">=</span> genp(fixed_noise_rec, st <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">true</span>) <span style="color:#75715e"># padded</span>
        amp <span style="color:#f92672">=</span> st <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1f0</span> <span style="color:#f92672">:</span> estimate_noise_amplifier(prev_rec, real_img_p[st], genp<span style="color:#f92672">.</span>pad, hp<span style="color:#f92672">.</span>amplifier_init)
        push!(amplifiers, amp)
        <span style="color:#75715e"># add noise for adv </span>
        fixed_noise_adv[st] <span style="color:#f92672">=</span> amp <span style="color:#f92672">*</span> randn_like(prev_rec, expand_dim(genp<span style="color:#f92672">.</span>noise_shapes[st]<span style="color:#f92672">...</span>))

        save_noise_amplifiers(st, amp)
        <span style="color:#a6e22e">@info</span> <span style="color:#e6db74">&#34;Noise amplifier = </span><span style="color:#e6db74">$</span>(amp)<span style="color:#e6db74">&#34;</span>

        <span style="color:#a6e22e">@time</span> <span style="color:#66d9ef">for</span> ep <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>hp<span style="color:#f92672">.</span>max_epoch
            <span style="color:#75715e"># reduce learnint rate</span>
            <span style="color:#66d9ef">if</span> ep <span style="color:#f92672">==</span> hp<span style="color:#f92672">.</span>reduce_lr_epoch
                <span style="color:#a6e22e">@info</span> <span style="color:#e6db74">&#34;Reduce learning rate&#34;</span>
                opt_dscr<span style="color:#f92672">.</span>eta <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>
                opt_gen<span style="color:#f92672">.</span>eta <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>
            <span style="color:#66d9ef">end</span>

            loss_dscr, loss_gen_adv, loss_gen_rec <span style="color:#f92672">=</span>
                train_epoch!(opt_dscr, opt_gen, st, hp<span style="color:#f92672">.</span>loop_dscr, hp<span style="color:#f92672">.</span>loop_gen,
                    dscrp<span style="color:#f92672">.</span>chains[st], genp, prev_rec, fixed_noise_rec[st], real_img_p[st], amplifiers, hp<span style="color:#f92672">.</span>alpha)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">end</span>

</code></pre></div><h3 id="アニメーション結果">アニメーション結果</h3>
<p>一応トレーニング関数まで到達したので、具体的な実行方法などは一番最後に載せたレポジトリを見てもらうこととして、とりあえずアニメーションの結果を見せたいと思います。
公式実装のアニメーションで使われている画像を強引に 64x64 にリサイズしたものを使いました。
<figure>
    <img src="/images/posts/fluxjl-singan_lightning_original.png"/> 
</figure>
</p>
<p>無理やり 256x256 に引き伸ばすとこんな感じです。
<figure>
    <img src="/images/posts/fluxjl-singan_lightning_original.png" width="256"/> 
</figure>
</p>
<p>25x25 のサイズからスタートして、64x64 で終了させたのですが、GCP の n1-standard-8 + K80 で一時間弱で学習が終わりました。
今回は Julia サイドで画像だけ吐き出して、アニメーション GIF は ImageMagick で作成しました。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ convert -delay <span style="color:#ae81ff">10</span> -loop <span style="color:#ae81ff">0</span> img*.png fluxjl-singan_lightning.gif
</code></pre></div><figure>
    <img src="/images/posts/fluxjl-singan_lightning.gif"/> 
</figure>

<p>実際の画像はかなり小さいので、256x256 に拡大するとこんな感じです。
もっと時間をかけて大きい画像まで学習すれば高精細な結果が得られると思います。
<figure>
    <img src="/images/posts/fluxjl-singan_lightning.gif" width="256"/> 
</figure>
</p>
<p>アルバムのジャケットをアニメーションさせた結果です。</p>
<figure>
    <img src="/images/posts/fluxjl-singan_floral.gif" width="256"/> 
</figure>

<figure>
    <img src="/images/posts/fluxjl-singan_farside.gif" width="256"/> 
</figure>

<p>まだまだ実装の改良の余地がありそうですが、一応一枚の画像だけを使ってアニメーション画像を作成するモデルを Flux.jl で実装できました。</p>
<p>詳細な部分も含めた全コードはこちらです。
<a href="https://github.com/matsueushi/SinGAN">matsueushi/SinGAN</a></p>
</div>
	</section>


</article>

		</main>
		<aside role="contentinfo"
			class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-4 md:order-3 md:sticky md:bottom-0 self-end max-w-2xl">
			<div class="md:float-right md:text-right leading-loose tracking-tight md:mb-2">
				
	<div class="md:max-w-xs  flex flex-col md:items-end">
	<ul class="font-serif flex-grow-0 flex justify-between flex-wrap md:flex-col">
	
	
	<li class="px-1 md:px-0">
		<a href="/" title="Home page" 
			class="font-medium text-medium-red-violet-600 hover:text-medium-red-violet-400" >
			Home
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/posts/" title="Blog page" 
			class="font-medium text-medium-red-violet-600 hover:text-medium-red-violet-400" >
			Blog
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/page/about/" title="About page" >
			About
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/page/memo/" title="Memo page" >
			Memo
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/page/boat/" title="BOaT page" >
			BOaT
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/tags/" title="Tags page" >
			Tags
		</a>
	</li>
	
	
	
</ul>
	

<div class="flex flex-wrap-reverse md:justify-end content-end md:content-start justify-start items-start  pb-2 max-h-16">
	
	<a href='http://github.com/matsueushi' target="_blank" class="github icon pl-1 text-eucalyptus-400 hover:text-java-400" title="github link" rel="noopener"
		aria-label="follow on github——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path fill-rule="nonzero" d="M5.883 18.653c-.3-.2-.558-.455-.86-.816a50.32 50.32 0 0 1-.466-.579c-.463-.575-.755-.84-1.057-.949a1 1 0 0 1 .676-1.883c.752.27 1.261.735 1.947 1.588-.094-.117.34.427.433.539.19.227.33.365.44.438.204.137.587.196 1.15.14.023-.382.094-.753.202-1.095C5.38 15.31 3.7 13.396 3.7 9.64c0-1.24.37-2.356 1.058-3.292-.218-.894-.185-1.975.302-3.192a1 1 0 0 1 .63-.582c.081-.024.127-.035.208-.047.803-.123 1.937.17 3.415 1.096A11.731 11.731 0 0 1 12 3.315c.912 0 1.818.104 2.684.308 1.477-.933 2.613-1.226 3.422-1.096.085.013.157.03.218.05a1 1 0 0 1 .616.58c.487 1.216.52 2.297.302 3.19.691.936 1.058 2.045 1.058 3.293 0 3.757-1.674 5.665-4.642 6.392.125.415.19.879.19 1.38a300.492 300.492 0 0 1-.012 2.716 1 1 0 0 1-.019 1.958c-1.139.228-1.983-.532-1.983-1.525l.002-.446.005-.705c.005-.708.007-1.338.007-1.998 0-.697-.183-1.152-.425-1.36-.661-.57-.326-1.655.54-1.752 2.967-.333 4.337-1.482 4.337-4.66 0-.955-.312-1.744-.913-2.404a1 1 0 0 1-.19-1.045c.166-.414.237-.957.096-1.614l-.01.003c-.491.139-1.11.44-1.858.949a1 1 0 0 1-.833.135A9.626 9.626 0 0 0 12 5.315c-.89 0-1.772.119-2.592.35a1 1 0 0 1-.83-.134c-.752-.507-1.374-.807-1.868-.947-.144.653-.073 1.194.092 1.607a1 1 0 0 1-.189 1.045C6.016 7.89 5.7 8.694 5.7 9.64c0 3.172 1.371 4.328 4.322 4.66.865.097 1.201 1.177.544 1.748-.192.168-.429.732-.429 1.364v3.15c0 .986-.835 1.725-1.96 1.528a1 1 0 0 1-.04-1.962v-.99c-.91.061-1.662-.088-2.254-.485z"/>
    </g>
</svg>

		</div>
	</a>
	
	<a href='http://twitter.com/matsue_ushi' target="_blank" class="twitter icon pl-1 text-eucalyptus-400 hover:text-java-400" title="twitter link" rel="noopener"
		aria-label="follow on twitter——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path fill-rule="nonzero" d="M15.3 5.55a2.9 2.9 0 0 0-2.9 2.847l-.028 1.575a.6.6 0 0 1-.68.583l-1.561-.212c-2.054-.28-4.022-1.226-5.91-2.799-.598 3.31.57 5.603 3.383 7.372l1.747 1.098a.6.6 0 0 1 .034.993L7.793 18.17c.947.059 1.846.017 2.592-.131 4.718-.942 7.855-4.492 7.855-10.348 0-.478-1.012-2.141-2.94-2.141zm-4.9 2.81a4.9 4.9 0 0 1 8.385-3.355c.711-.005 1.316.175 2.669-.645-.335 1.64-.5 2.352-1.214 3.331 0 7.642-4.697 11.358-9.463 12.309-3.268.652-8.02-.419-9.382-1.841.694-.054 3.514-.357 5.144-1.55C5.16 15.7-.329 12.47 3.278 3.786c1.693 1.977 3.41 3.323 5.15 4.037 1.158.475 1.442.465 1.973.538z"/>
    </g>
</svg>

		</div>
	</a>
	
</div>
	<div class="text-sm text-gray-500 leading-tight a-gray">
		Copyright © 2019–2020
		<br />
		Built with Hugo and theme <a href="https://github.com/heyeshuang/hugo-theme-tokiwa">Tokiwa</a>. 5785 words in this page.
	</div>
</div>

			</div>
		</aside>
		<footer class="w-full md:w-3/5 xl:w-1/2 order-3 max-w-3xl md:order-4 pt-2">
			

<hr class="double-line" />
<div>
    <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>
<div class="flex flex-wrap justify-between pb-2 leading-loose font-serif">
    
    <a class="flex-grow-0" href="/posts/fluxjl-dcgan/">
        <svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24"
            height="24">
            <path fill="none" d="M0 0h24v24H0z" />
            <path d="M7.828 11H20v2H7.828l5.364 5.364-1.414 1.414L4 12l7.778-7.778 1.414 1.414z" /></svg>
        Flux.jl v0.10.0でDCGANを動かす(CUDA環境)
    </a>
    
    
    <a class="flex-grow-0" href="/posts/julia-rounding/">
        Juliaで丸めモードを指定して浮動小数点数の計算をする(したい)
        <svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24"
            height="24">
            <path fill="none" d="M0 0h24v24H0z" />
            <path d="M16.172 11l-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2z" /></svg></a>
    
</div>
<div >



<div class="font-serif pb-2 flex align-start leading-loose">
	<span class="heading pr-6 leading-loose">Related</span>
	<span >
		
			<a href="/posts/fluxjl-dcgan/">Flux.jl v0.10.0でDCGANを動かす(CUDA環境)</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/julia-identity/">Juliaの単位行列</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/clustering-kmean/">K-平均アルゴリズム</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/gaussianprocess-jl-2/">Juliaのガウス過程ライブラリGaussianProcesses.jlを使う(ハイパーパラメーター推定)</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/gaussianprocess-jl/">Juliaのガウス過程ライブラリGaussianProcesses.jlを使う(基本編)</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/gp-parameter-estimation/">Juliaでガウス過程を実装&amp;パラメーター推定</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/gp-nlp-2/">ガウス過程と機械学習: 3.5まで</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/gp-nlp-1/">「ガウス過程と機械学習 」を読み始めた</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/shift-scale-distribution/">Distribution.jlで分布をシフト・スケールさせる</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/bayesian-methods-julia-7/">Juliaで体験するベイズ推論(7) - The Price Is Right</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/bayesian-methods-julia-6/">Juliaで体験するベイズ推論(6) -スペースシャトル「チャレンジャー号」の悲劇</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/rollingwindow/">JuliaでRollingWindow</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/julia-array-dim/">Juliaの2次元のArrayを1次元にする / Juliaの3次元のArrayを2次元にする</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/mamba-gaussianrandomwalk/">Mamba.jlでGaussianRandomWalkを作って使う</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/mamba-v-0-12-0/">Mamba.jl v0.12.0のStackOverflowError:</a>
		
</span>
</div>

</div>
<hr />
<div class="pb-2">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "matsueushi-github-io" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
<hr />

		</footer>
		

<script src="/dist/app.js"></script>

	</div>
</body>

</html>