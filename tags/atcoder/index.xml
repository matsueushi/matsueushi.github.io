<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AtCoder on matsueushi</title>
    <link>https://matsueushi.github.io/tags/atcoder/</link>
    <description>Recent content in AtCoder on matsueushi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Copyright © 2019–2022</copyright>
    <lastBuildDate>Mon, 06 Jun 2022 22:06:55 +0900</lastBuildDate>
    
	<atom:link href="https://matsueushi.github.io/tags/atcoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AtCoder ABC 153 E - Crested Ibis vs Monster</title>
      <link>https://matsueushi.github.io/atcoder/abc153-e/</link>
      <pubDate>Mon, 06 Jun 2022 22:06:55 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc153-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/tasks/abc153_e&#34;&gt;https://atcoder.jp/contests/abc153/tasks/abc153_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(dp[i][k]\) = \(i\) 番目までの魔法からダメージが \(k\) 以上になるように選んだ時に消費するMPの最小値&lt;/p&gt;
&lt;p&gt;とすると、個数制限なしナップザック問題（の類似）に帰着される。
(参考:蟻本の2章 p.p.58 漸化式を工夫する)&lt;/p&gt;
&lt;p&gt;\(dp[i+1][k] = \min(dp[i][k], dp[i+1][k-a[i]]+b[i])\)&lt;/p&gt;
&lt;p&gt;である。ここで、\(dp[-1][k] = 0\) と \(dp[i][k] = 0 \ (k &amp;lt; 0)\) とおいた。&lt;/p&gt;
&lt;p&gt;答えは \(dp[n][h]\) であり、\(O(nh)\) で求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/submissions/32290815&#34;&gt;https://atcoder.jp/contests/abc153/submissions/32290815&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC161 D - Lunlun Number</title>
      <link>https://matsueushi.github.io/atcoder/abc161-d/</link>
      <pubDate>Sun, 05 Jun 2022 21:16:30 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc161-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc161/tasks/abc161_d&#34;&gt;https://atcoder.jp/contests/abc161/tasks/abc161_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;桁数の少ないルンルン数から順に作っていけば良い。&lt;/p&gt;
&lt;p&gt;1桁のルンルン数 = 1,2,&amp;hellip;,9&lt;/p&gt;
&lt;p&gt;2桁のルンルン数 = ([1 桁のルンルン数][最後の数字に-1,0,+1のどれかを足したもの]の順に繋げた数)&lt;/p&gt;
&lt;p&gt;3桁のルンルン数 = ([2 桁のルンルン数][最後の数字に-1,0,+1のどれかを足したもの]の順に繋げた数)&lt;/p&gt;
&lt;p&gt;このように考えていくと、自然にルンルン数が昇順に列挙できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc161/submissions/32271070&#34;&gt;https://atcoder.jp/contests/abc161/submissions/32271070&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder CODE FESTIVAL 2017 qualC C - Inserting &#39;x&#39;</title>
      <link>https://matsueushi.github.io/atcoder/code-festival-2017-qualc-d/</link>
      <pubDate>Sun, 05 Jun 2022 18:08:29 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/code-festival-2017-qualc-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/code-festival-2017-qualc/tasks/code_festival_2017_qualc_c&#34;&gt;https://atcoder.jp/contests/code-festival-2017-qualc/tasks/code_festival_2017_qualc_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目標が達成可能かどうかは、s から &amp;lsquo;x&amp;rsquo; を取り除いてできる文字列が回文であるかどうかで判定できる。
以後、目標が達成可能な場合を考える。&lt;/p&gt;
&lt;p&gt;s の &amp;lsquo;x&amp;rsquo; でない文字列のうち左から i 番目の文字を \(cs[i]\) とする。(i = 1,&amp;hellip;,m とする)&lt;/p&gt;
&lt;p&gt;\(ds[i]\) を \(cs[i]\) と \(cs[i+1]\) の間にある &amp;lsquo;x&amp;rsquo; の個数とする。
\(ds[0]\) を \(cs[1]\) の前にある &amp;lsquo;x&amp;rsquo; の数、\(ds[m]\) を \(cs[m]\) の後にある &amp;lsquo;x&amp;rsquo; の数と拡張しておく。&lt;/p&gt;
&lt;p&gt;s = &amp;ldquo;xabxa&amp;rdquo; の時は、cs = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ds = [1,0,1,0]である。&lt;/p&gt;
&lt;p&gt;&amp;lsquo;x&amp;rsquo; を挿入する操作は、ds の一つの数字を +1 することに相当する。ds が左右対称となった時文字列が回文になるから、
答えは l = length(ds) として \(\sum_{i=1}^{\lfloor l/2 \rfloor}|ds[i] - ds[l-i+1]| \) で求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/code-festival-2017-qualc/submissions/32267860&#34;&gt;https://atcoder.jp/contests/code-festival-2017-qualc/submissions/32267860&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 034 A - Kenken Race</title>
      <link>https://matsueushi.github.io/atcoder/agc034-a/</link>
      <pubDate>Sat, 04 Jun 2022 18:32:50 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/agc034-a/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/tasks/agc034_a&#34;&gt;https://atcoder.jp/contests/agc034/tasks/agc034_a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;すぬけくんしかいない場合を考えると、a地点からc地点に到達できる条件は、\([a,c]\)の間に連続する黒マスがないこと、である。&lt;/p&gt;
&lt;p&gt;2人いる場合を考えると、\(c&amp;lt;d \) の場合は、すぬけくんとふぬけくんの順序を入れ替える必要がないから、
ふぬけくんに先にゴースさせて、すぬけくんがその後ゴールすれば良い。
よって、一人だけの場合の条件をすぬけくん、ふぬけくんでそれぞれ考える。&lt;/p&gt;
&lt;p&gt;\(c &amp;gt; d \) の場合、順序を入れ替える必要がある。順序が入れ替わるのは、&lt;/p&gt;
&lt;p&gt;(す)(ふ)(空)&lt;/p&gt;
&lt;p&gt;という状態になっている時だから、ふぬけくんの現在いる位置、またはそれより右側で、前後が白マスになっているところを探す。
つまり、三連続で白マスになっている場所を探す。&lt;/p&gt;
&lt;p&gt;この時、候補の中で1番左の位置にある三連続白マスを考えれば良い。(状態が実現できなければ、それより右の三連続白マスで実現することは不可能のため)&lt;/p&gt;
&lt;p&gt;後は、&lt;/p&gt;
&lt;p&gt;(す)(ふ)(空)&lt;/p&gt;
&lt;p&gt;の状態に到達できるか確認して、到達できれば、順番を入れ替える必要がない\(c &amp;lt; d \)の場合に帰着できる。
この時、当初の目的地を飛び越えていないかもチェックする。
到達できなければ、実現不可能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/submissions/32194980&#34;&gt;https://atcoder.jp/contests/agc034/submissions/32194980&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder AGC 011 B - Colorful Creatures</title>
      <link>https://matsueushi.github.io/atcoder/agc011-b/</link>
      <pubDate>Thu, 02 Jun 2022 23:12:47 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/agc011-b/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc011/tasks/agc011_b&#34;&gt;https://atcoder.jp/contests/agc011/tasks/agc011_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(A_i\) を降順にソートしても一般性を失わない。&lt;/p&gt;
&lt;p&gt;大きいものの方が吸収しづらいから、1番最後に\(1\), その前に \(2, \ldots, \)を吸収したとして良い。
\(A_1, \ldots, A_i\) を吸収するのに必要な最小のとなる生き物の大きさの整数値を \(B_i\) とする。&lt;/p&gt;
&lt;p&gt;\(B_1 = \lceil A_1 / 2\rceil \) である。
\(A_i\) が吸収でき、さらにその後 \(i-1, \ldots, 1\) が吸収できる条件を考えると、
\(B_i = \max(\lceil A_i / 2 \rceil, B_{i-1}-A_i)\) である。&lt;/p&gt;
&lt;p&gt;各 \(i \) に対し、\(i\) は \(i+1\) 以降を吸収できるから、\( \sum_{k=i}^n A_k \ge B_{i-1} \) を満たすかどうか判定すれば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc011/submissions/32165993&#34;&gt;https://atcoder.jp/contests/agc011/submissions/32165993&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 134 D - Preparing Boxes</title>
      <link>https://matsueushi.github.io/atcoder/abc134-d/</link>
      <pubDate>Wed, 01 Jun 2022 22:16:01 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc134-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/tasks/abc134_d&#34;&gt;https://atcoder.jp/contests/abc134/tasks/abc134_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件を満たすボールの入れ方は、一意に定まる。&lt;/p&gt;
&lt;p&gt;n = 4 の場合、4 までに 3, 4 の倍数は一つしかないので、
| | |X|X|
a_3, a_4 の情報から i = 3,4 のボールの個数が確定する。&lt;/p&gt;
&lt;p&gt;次に、a_2 の情報から i = 2 のボールの個数が確定する。最後に i = 1 が確定する。&lt;/p&gt;
&lt;p&gt;このように考えると、第 k ステップで i ≥ floor(n/2^k) の場所のボールの個数が確定することがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/submissions/32148310&#34;&gt;https://atcoder.jp/contests/abc134/submissions/32148310&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 064 D - Insertion</title>
      <link>https://matsueushi.github.io/atcoder/abc064-d/</link>
      <pubDate>Tue, 31 May 2022 22:18:08 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc064-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/tasks/abc064_d&#34;&gt;https://atcoder.jp/contests/abc064/tasks/abc064_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先頭に&amp;quot;(&amp;quot;, 末尾に&amp;quot;)&amp;ldquo;を繋げて括弧列を作るのが辞書式最小となる。
(そのような作り方をしないと、より左の位置に&amp;rdquo;)&amp;ldquo;が出現する)&lt;/p&gt;
&lt;p&gt;&amp;ldquo;(&amp;rdquo; -&amp;gt; +1, &amp;ldquo;)&amp;rdquo; -&amp;gt; -1 と文字列を置き換えて累積和を取ったものを c[i] とすると、
c[i] ≥ 0 (1≤i≤n-1), c[n] = 0 が括弧列を成立させる条件である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/submissions/32131694&#34;&gt;https://atcoder.jp/contests/abc064/submissions/32131694&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 133 D - Rain Flows into Dams</title>
      <link>https://matsueushi.github.io/atcoder/abc133-d/</link>
      <pubDate>Tue, 31 May 2022 21:40:17 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc133-d/</guid>
      <description>&lt;p&gt;山 i に降った雨の量を \(2 * x_i\) とすると、\(\sum A_i = 2 \sum x_i\) だから、\(x_i\) の合計がわかる。&lt;/p&gt;
&lt;p&gt;Nが奇数であることから \(A_i = x_i + x_{i+1}\) をうまく足して \(\sum_{i \neq j} x_i\) が作れ、合計から引くことで \(x_j\) が求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc133/submissions/32131263&#34;&gt;https://atcoder.jp/contests/abc133/submissions/32131263&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 094 C - Many Medians</title>
      <link>https://matsueushi.github.io/atcoder/abc094-c/</link>
      <pubDate>Mon, 30 May 2022 23:21:40 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc094-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc094/tasks/arc095_a&#34;&gt;https://atcoder.jp/contests/abc094/tasks/arc095_a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まず、具体例で考えてみる。aがソートされている場合を考えよう。&lt;/p&gt;
&lt;p&gt;1,2,3,4,5&lt;/p&gt;
&lt;p&gt;で左からi番目の数を取り除いた中央値を考えると&lt;/p&gt;
&lt;p&gt;3,3,2,2,2&lt;/p&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;1,2,2,3&lt;/p&gt;
&lt;p&gt;であれば&lt;/p&gt;
&lt;p&gt;2,2,2&lt;/p&gt;
&lt;p&gt;である。&lt;/p&gt;
&lt;p&gt;よって、pos = floor((l+1)/2), 取り除かれた値をxとすると、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;l が偶数の時&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;x ≤ a[pos] -&amp;gt; 取り除いた後は a[pos+1] が中央値&lt;/li&gt;
&lt;li&gt;x &amp;gt; a[pos] -&amp;gt; a[pos]&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;l が奇数の時&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;lt; a[pos] -&amp;gt; a[pos]&lt;/li&gt;
&lt;li&gt;x ≥ a[pos] -&amp;gt; a[pos-1]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;であることがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc094/submissions/32115333&#34;&gt;https://atcoder.jp/contests/abc094/submissions/32115333&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 183 E - Queen on Grid</title>
      <link>https://matsueushi.github.io/atcoder/abc183-e/</link>
      <pubDate>Mon, 30 May 2022 23:05:11 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc183-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/tasks/abc183_e&#34;&gt;https://atcoder.jp/contests/abc183/tasks/abc183_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まず1次元で右にしか進めない場合を考える。
dp[i]=左からi番目に移動する方法
とする。&lt;/p&gt;
&lt;p&gt;dp[i]=2^(n-1)である。1,…,i-1それぞれで立ち止まるか通過するか選べると考えてもいいが、dp[1]=1であり、i番目にいる時、移動をそこでやめてそこで立ち止まってi+1に進むか、そのまま移動してi+1に行くかの2通りがあるので、dp[i+1]=2*dp[i]であると考えられる。&lt;/p&gt;
&lt;p&gt;2次元にすると、向きが変わる場合があるので&lt;/p&gt;
&lt;p&gt;各マスでの状態を&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;右向きで進んでいる&lt;/li&gt;
&lt;li&gt;下向きに進んでいる&lt;/li&gt;
&lt;li&gt;斜め右下向きに進んでいる&lt;/li&gt;
&lt;li&gt;立ち止まっている&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;という状態も含めて考える。
dp[1,1,1]=1,dp[1,1,k]=0 (k=1,2,3)で、&lt;/p&gt;
&lt;p&gt;dp[i,j,1]=dp[i-1,j,1]+dp[i-1,j,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,2]=dp[i,-1j,2]+dp[i,j-1,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,3]=dp[i-1,j-1,3]+dp[i-1,j-1,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,4]=dp[i-1,j,1]+dp[i,j-1,2]+dp[i-1,j-1,3] + dp[i-1,j,4]+dp[i,j-1,4]+dp[i-1,j-1,4]&lt;/p&gt;
&lt;p&gt;最後に(h,w)で着地する必要があるので、dp[h,w,4]が答えである。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/submissions/32114608&#34;&gt;https://atcoder.jp/contests/abc183/submissions/32114608&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 130 C - Rectangle Cutting</title>
      <link>https://matsueushi.github.io/atcoder/abc130-c/</link>
      <pubDate>Mon, 30 May 2022 21:40:55 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc130-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc130/tasks/abc130_c&#34;&gt;https://atcoder.jp/contests/abc130/tasks/abc130_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長方形の対角線の交点をCとする。C=(x,y)ならどのように切っても長方形の面積を二等分できる。
そうでない場合はCと(x,y)を結ぶと二等分できる。
よって最初の答えは(x,y)の位置に関係なく長方形の面積の半分。最適な切り方が複数あるかは、C=(x,y)であるかどうか。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc130/submissions/32113015&#34;&gt;https://atcoder.jp/contests/abc130/submissions/32113015&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder DISCO presents ディスカバリーチャンネル コードコンテスト2020 予選 C - Strawberry Cakes</title>
      <link>https://matsueushi.github.io/atcoder/ddcc2020-qual-c/</link>
      <pubDate>Sat, 28 May 2022 19:55:21 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/ddcc2020-qual-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_c&#34;&gt;https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各行に一つ以上イチゴが乗っている場合、行ごとに分割すれば目的が達成できる。
ある行に注目したときに、&lt;/p&gt;
&lt;p&gt;|🍓|　|　|🍓|　|　|&lt;/p&gt;
&lt;p&gt;であれば&lt;/p&gt;
&lt;p&gt;|1|2|2|2|2|2|&lt;/p&gt;
&lt;p&gt;のような帯に切り分ける。これを繰り返していくとイチゴが乗っていない行以外は、
行だけで注目するとイチゴが一つだけ乗った長方形のケーキに分かれる。
後はイチゴが1つも乗っていない行の切り方をイチゴが乗っている上の行か下の行に合わせて長方形になるようにする。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/ddcc2020-qual/submissions/31996005&#34;&gt;https://atcoder.jp/contests/ddcc2020-qual/submissions/31996005&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 137 D - Summer Vacation</title>
      <link>https://matsueushi.github.io/atcoder/abc137-d/</link>
      <pubDate>Thu, 26 May 2022 23:47:34 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc137-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc137/tasks/abc137_d&#34;&gt;https://atcoder.jp/contests/abc137/tasks/abc137_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;後ろから貪欲法で解ける気がする。
M-1日目を考えると、 残っている仕事のうち、
Ai=1を満たす仕事で報酬Biが最大となるものを請けるとして良いことがわかる。&lt;/p&gt;
&lt;p&gt;必要であれば受けた仕事の順番を入れ替えて、
M-1日目にする仕事は、全てのN件の日雇いバイトの中でAi=1を満たし報酬Biが最大となる仕事である、とできる。&lt;/p&gt;
&lt;p&gt;次にM-2日目を考えると、できる仕事はAi=1,2である仕事。Ai=1,Biが最大となる仕事は最終日にやることが決まっているので、
M-1日目と同様の考察により、それを除いた仕事のうち報酬が最大となるものを働けば良い。&lt;/p&gt;
&lt;p&gt;以下繰り返す。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc137/submissions/31967629&#34;&gt;https://atcoder.jp/contests/abc137/submissions/31967629&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 117 C - Streamline</title>
      <link>https://matsueushi.github.io/atcoder/abc117-c/</link>
      <pubDate>Wed, 25 May 2022 23:28:21 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc117-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc117/tasks/abc117_c&#34;&gt;https://atcoder.jp/contests/abc117/tasks/abc117_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数直線上に地点X_iを配置して、コマが移動した位置を塗りつぶすことを考える。&lt;/p&gt;
&lt;p&gt;移動回数を最小化したいので、塗りつぶす面積を最小化することを考える。&lt;/p&gt;
&lt;p&gt;X_1, &amp;hellip;, X_M によって M-1 個の区間が作られる。&lt;/p&gt;
&lt;p&gt;N=1だったら全ての区間をぬりぶさないとM個の地点全てに到達できない。
N=2だったら一つの区間は塗りつぶさずにスキップできる。
このように考えると、最大N-1個の区間は塗りつぶさずにスキップ可能であることがわかる。
よって、塗りつぶさないといけない区間はmax(0, M-N)個。&lt;/p&gt;
&lt;p&gt;区間の長さをソートし、短い順にmax(0, M-N)個の区間の長さの合計を求めると答えになる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc117/submissions/31965997&#34;&gt;https://atcoder.jp/contests/abc117/submissions/31965997&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder みんなのプロコン2019 C - When I hit my pocket...</title>
      <link>https://matsueushi.github.io/atcoder/yahoo-procon2019-c/</link>
      <pubDate>Wed, 25 May 2022 23:05:47 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/yahoo-procon2019-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_c&#34;&gt;https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;円は残しておいても最終的なビスケットの枚数の最大値には寄与しない。また、使い道はビスケットB枚に交換することのみ。&lt;/p&gt;
&lt;p&gt;よって、Kアクション与えられた際、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1アクション使って、ビスケットを1枚増やす&lt;/li&gt;
&lt;li&gt;2アクション使って、ビスケットA枚をビスケットB枚に交換する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この二つの選択の組み合わせでビスケットの枚数を最大化する、という問題に帰着される。&lt;/p&gt;
&lt;p&gt;一つ目の行動を二回繰り返すとビスケットが2枚増える、ということは B&amp;gt;A+2でないと二つ目の行動をする意味がない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B&amp;gt;A+2であったら二つ目の行動の方が効率が良いので、一つ目の行動でビスケットをA枚まで増やした後二つ目の行動を繰り返し、アクションが最後に1残ったら最後にもう一枚増やす&lt;/li&gt;
&lt;li&gt;B≤A+2だったら一つ目の行動を連打&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;で良い。後はkとaの大小関係に注意すればOK&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/31952356&#34;&gt;https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/31952356&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 154 E - Almost Everywhere Zero</title>
      <link>https://matsueushi.github.io/atcoder/abc154-e/</link>
      <pubDate>Wed, 25 May 2022 21:30:34 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc154-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc154/tasks/abc154_e&#34;&gt;https://atcoder.jp/contests/abc154/tasks/abc154_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(N\) の上 \(i\) 桁をつなげた数を \(N(i)\) とする。
\(N\) の上から \(i\) 桁目を \(N_i\) とする。\(N\) の桁数を \(l\) とする。&lt;/p&gt;
&lt;p&gt;\(dp[i,k,0] = \{ n \in \mathbb{Z} \mid  n &amp;lt; N(i) ,n の 0 でない数字の数が k \}\)
\(dp[i,k,1] = \{ n \in \mathbb{Z} \mid  n = N(i) ,n の 0 でない数字の数が k \}\)
とすると、求めたいのは \(dp[l,K,0] + dp[l,K,1]\) である。&lt;/p&gt;
&lt;p&gt;\(dp[i,0,0]=1, \) (0 に対応)&lt;/p&gt;
&lt;p&gt;\(dp[1,1,0] = N_1-1,\) (1,&amp;hellip;,N1- 1に対応)&lt;/p&gt;
&lt;p&gt;\(dp[1,k,0]= 0 (k \ge 2),\)&lt;/p&gt;
&lt;p&gt;\(dp[1,k,1] = 1,\)&lt;/p&gt;
&lt;p&gt;遷移を考えると&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,0] = dp[i,k,0]+9\cdot dp[i,k-1,0] (k \ge 1, N_{i+1}=0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,0] = dp[i,k,0]+9\cdot dp[i,k-1,0]+dp[i,k,1]+(N_{i+1}-1)dp[i,k-1,1] (k \ge 1, N_{i+1}\neq 0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,1] = dp[i,k,1] (N_{i+1} = 0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,1] = dp[i,k-1,1](N_{i+1} \neq 0),\)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc154/submissions/31951620&#34;&gt;https://atcoder.jp/contests/abc154/submissions/31951620&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;調べてみたらこういうものを桁DPというらしい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考
&lt;a href=&#34;https://algo-logic.info/digit-dp/&#34;&gt;桁DP(Digit DP) を考え方から問題例まで徹底解説！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 135 C - City Savers</title>
      <link>https://matsueushi.github.io/atcoder/abc135-c/</link>
      <pubDate>Wed, 25 May 2022 21:19:09 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc135-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc135/tasks/abc135_c&#34;&gt;https://atcoder.jp/contests/abc135/tasks/abc135_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;勇者が倒せるモンスターの数を無駄にしたくないので、
他の勇者が倒せるモンスターよりも自分しか倒せないモンスターを優先して倒すようにする。&lt;/p&gt;
&lt;p&gt;1番目の街のモンスターは1番目の勇者しか倒せないので、1番目の勇者は優先的に1番目の街のモンスターを倒し、
余力があれば2番の街のモンスターを倒す。
2番目の勇者は残っている2番目の街ののモンスターから倒す……
と順々に考えれば良い&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc135/submissions/31950249&#34;&gt;https://atcoder.jp/contests/abc135/submissions/31950249&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderで緑色になった</title>
      <link>https://matsueushi.github.io/atcoder/green/</link>
      <pubDate>Sun, 15 May 2022 21:55:31 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/green/</guid>
      <description>&lt;p&gt;4月頭からAtCoder Beginner Contestに出ていたのですが、緑色になりました。
&lt;a href=&#34;https://atcoder.jp/users/matsueushi&#34;&gt;https://atcoder.jp/users/matsueushi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;蟻本を読みながら「競プロ典型90問」を9割ぐらい解答を見ながら解いて、その後はABCの過去問をA-D問題を中心に解いていました。
D問題で時間がかかってしまうことが多いので、&lt;a href=&#34;https://kenkoooo.com/atcoder/#/training/Boot%20camp%20for%20Beginners&#34;&gt;AtCoder Problems&lt;/a&gt; の「Boot camp for Beginners」を解きまくろうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 250 E - Prefix Equality</title>
      <link>https://matsueushi.github.io/atcoder/abc250-e/</link>
      <pubDate>Mon, 09 May 2022 21:47:26 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc250-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc250/tasks/abc250_e&#34;&gt;https://atcoder.jp/contests/abc250/tasks/abc250_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中は解けそうで解けなかったが、シンプルな方法で解けることにあとから気づいて悔やまれた。&lt;/p&gt;
&lt;p&gt;\(S_i= \{a_1, \ldots, a_i\}, T_i=\{b_i, \ldots, b_i \} \)とおくと、\( S_1 \subseteq S_2 \subseteq \cdots \subseteq S_n, T_1 \subseteq T_2 \subseteq \cdots \subseteq T_n\)となる。&lt;/p&gt;
&lt;p&gt;\(f_i= \max \{j \mid T_j \subseteq S_i \}, g_i= \max \{j \mid S_j \subseteq T_i \} \) を計算する。例えば\(f_i\)まで計算した後に\(f_{i+1}\)を計算するときは、\(b_{f_i+1}, b_{f_i+2}, \ldots , b_j\) が \(S_{i+1}\) に含まれているかをチェックしていき含まれなくなったら\(f_{i+1}=j-1\) とすれば良い。&lt;/p&gt;
&lt;p&gt;後は\(S_i = T_j \Leftrightarrow S_i \subseteq T_j, T_j \subseteq S_i \Leftrightarrow i \le g_j, j \le f_i\)でクエリを判定すれば良い。&lt;/p&gt;
&lt;p&gt;(Julia, 564 ms)
&lt;a href=&#34;https://atcoder.jp/contests/abc250/submissions/31571164&#34;&gt;https://atcoder.jp/contests/abc250/submissions/31571164&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JuliaでAtCoderに挑戦</title>
      <link>https://matsueushi.github.io/atcoder/julia-atcoder/</link>
      <pubDate>Fri, 04 Feb 2022 23:09:38 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/julia-atcoder/</guid>
      <description>&lt;p&gt;去年は色々と忙しくじっくり勉強する時間がなかったので、リハビリを兼ねて競技プログラミングの問題をJuliaで挑戦してみることにします。&lt;/p&gt;
&lt;p&gt;ひとまず、AtCoderの&lt;a href=&#34;https://atcoder.jp/contests/typical90&#34;&gt;競プロ典型 90 問&lt;/a&gt;を解いて行く予定です。
ジャッジ時にJITコンパイルが走って200~300ms程度消費してしまいますが、幸い今のところTLEでどう頑張っても通せない問題はなかったです。&lt;/p&gt;
&lt;p&gt;下に解答を記録していこうと思います。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/matsueushi/CompetitiveProgramming&#34;&gt;https://github.com/matsueushi/CompetitiveProgramming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;さてはて、いつまで続くやら。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderメモ書き</title>
      <link>https://matsueushi.github.io/atcoder/memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/memo/</guid>
      <description>&lt;p&gt;自分用&lt;/p&gt;
&lt;h2 id=&#34;dfs&#34;&gt;DFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc138/tasks/abc138_d&#34;&gt;ABC 138 D - Ki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;木を辿る&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc220/tasks/abc220_f&#34;&gt;ABC 220 F - Distance Sums 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bfs&#34;&gt;BFS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc151/tasks/abc151_d&#34;&gt;ABC 151 D - Maze Master&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bit全探索&#34;&gt;Bit全探索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc147/tasks/abc147_c&#34;&gt;ABC 147 C - HonestOrUnkind2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;区間スケジュール問題&#34;&gt;区間スケジュール問題&lt;/h2&gt;
&lt;p&gt;キーエンス2020 B Robot Arms&lt;/p&gt;
&lt;h2 id=&#34;dp&#34;&gt;DP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;ABC 154 E Almost Everywhere Zero&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1次元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/tasks/agc034_a&#34;&gt;AGC 034 A - Kenken Race&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2次元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/tasks/abc183_e&#34;&gt;ABC 183 E - Queen on Grid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc043/tasks/agc043_a&#34;&gt;AGC 043 A - Range Flip Find Route&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ナップザック問題&#34;&gt;ナップザック問題&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/tasks/abc153_e&#34;&gt;ABC 153 E - Crested Ibis vs Monster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数列&#34;&gt;数列&lt;/h2&gt;
&lt;p&gt;数列の連続する項目が離れている条件-&amp;gt;累積和&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc253/tasks/abc253_e&#34;&gt;ABC 253 E Distance Sequence&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ダイクストラ&#34;&gt;ダイクストラ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc252/tasks/abc252_e&#34;&gt;ABC 252 E Road Reduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ワーシャルフロイド&#34;&gt;ワーシャルフロイド&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc079/tasks/abc079_d&#34;&gt;ABC 079 D - Wall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;fenwick-tree&#34;&gt;Fenwick Tree&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc253/tasks/abc253_f&#34;&gt;ABC 254 F - Operations on a Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;括弧&#34;&gt;括弧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/tasks/abc064_d&#34;&gt;ABC 064 D - Insertion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;約数&#34;&gt;約数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/tasks/abc134_d&#34;&gt;ABC 134 D - Preparing Boxes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;素数&#34;&gt;素数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc084/tasks/abc084_d&#34;&gt;ABC 084 D - 2017-like Number&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三角形&#34;&gt;三角形&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc143/tasks/abc143_d&#34;&gt;ABC 143 D - Triangles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lca&#34;&gt;LCA&lt;/h2&gt;
&lt;p&gt;蟻本 pp.292&lt;/p&gt;
&lt;p&gt;\(d(u,v)=depth(u)+depth(v)-2depth(lca(u,v))\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/e869120/status/1391218516129312768&#34;&gt;競プロ典型90問 35日目解説@e869120&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;チェスのナイト&#34;&gt;チェスのナイト&lt;/h2&gt;
&lt;p&gt;斜めに動くとわかりづらいので、座標変換を行う。
$$
\begin{aligned}
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right) =
\left(
\begin{matrix}
1 &amp;amp; 2 \\
2 &amp;amp; 1
\end{matrix}
\right)
\left(
\begin{matrix}
s \\
t
\end{matrix}
\right)
\end{aligned}
$$
だから、逆変換
$$
\begin{aligned}
\left(
\begin{matrix}
s \\
t
\end{matrix}
\right) =
\cfrac{1}{3}
\left(
\begin{matrix}
1 &amp;amp; -2 \\
-2 &amp;amp; 1
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\end{aligned}
$$
を考えることにより縦横の単純な移動に変換する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蟻本 pp.353 Endless Knight&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;julia-特有のテクニック&#34;&gt;Julia 特有のテクニック&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;StringからVector{Char}への変換&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Vector&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Char&lt;/span&gt;}(s)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;これだけでいい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;負の数の剰余&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; mod(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>