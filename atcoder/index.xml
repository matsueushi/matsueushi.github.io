<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AtCoder on matsueushi</title>
    <link>https://matsueushi.github.io/atcoder/</link>
    <description>Recent content in AtCoder on matsueushi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>Copyright © 2019–2023</copyright>
    <lastBuildDate>Sun, 02 Apr 2023 21:30:06 +0900</lastBuildDate>
    
	<atom:link href="https://matsueushi.github.io/atcoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MC Digital プログラミングコンテスト2023（AtCoder Heuristic Contest 019）参加記</title>
      <link>https://matsueushi.github.io/atcoder/ahc019/</link>
      <pubDate>Sun, 02 Apr 2023 21:30:06 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/ahc019/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/ahc019&#34;&gt;MC Digital プログラミングコンテスト2023（AtCoder Heuristic Contest 019）&lt;/a&gt; の参加記です。&lt;/p&gt;
&lt;p&gt;下はseed=40の結果(score=165,708,812)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/ahc019-vis1.png&#34; alt=&#34;vis1&#34;&gt;
&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/ahc019-vis2.png&#34; alt=&#34;vis2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;問題概略&#34;&gt;問題（概略）&lt;/h3&gt;
&lt;p&gt;正面・右側から見た立体のシルエットの組が二つ与えられる。
両方のシルエットが実現できるようなブロックのセットを作る。
二つの立体を作るときに、できるだけブロックを共通して使うようにしたい。
また、小さなブロックは飲み込みやすく危険なので可能な限りセットを構成するブロックは大きくしたい。&lt;/p&gt;
&lt;h3 id=&#34;2023323&#34;&gt;2023/3/23&lt;/h3&gt;
&lt;p&gt;同じ立体問題だった前回の&lt;a href=&#34;https://atcoder.jp/contests/toyota-hc-2023spring&#34;&gt;トヨタ自動車 実課題プログラミングコンテスト 2023 Spring&lt;/a&gt; ではそもそもACすることに苦戦し、なんとかプレテストではACに漕ぎつけたものの、システムテストでWAとなってしまっていた。
そのため、立体問題に苦手意識が生まれてしまい、AHCにとっては参加登録をしたものの数日取り組むことなく放置していた。&lt;/p&gt;
&lt;p&gt;問題を読んでみる。うーん、難しそうだ。全く解法が思いつかない。
サンプルプログラムが付いていたのでこれをRustに移植して提出。全てをサイズ1のブロックで埋めている。
20,662,000,000,000点を得てこの日は終了。&lt;/p&gt;
&lt;h3 id=&#34;2023324&#34;&gt;2023/3/24&lt;/h3&gt;
&lt;p&gt;ローカル版ビジュアライザのソースコードを参考にして、スコアを計算するコードを作る。&lt;/p&gt;
&lt;h3 id=&#34;2023325&#34;&gt;2023/3/25&lt;/h3&gt;
&lt;p&gt;次のような方針を思いつく。この後、最後まで大きな方針は変わらず。&lt;/p&gt;
&lt;p&gt;(1) 左のスペースから立方体を置ける座標$p_l$を選ぶ。&lt;/p&gt;
&lt;p&gt;(2) 右のスペースで原点とする座標$p_r$を選ぶ。&lt;/p&gt;
&lt;p&gt;(3) スタック$s$に左から選んだ座標を入れる。&lt;/p&gt;
&lt;p&gt;(4) 左で伸ばしていくブロックを管理するリスト$cs$を用意。最初は空とする。&lt;/p&gt;
&lt;p&gt;(5) スタックから座標$c$を取り出す。&lt;/p&gt;
&lt;p&gt;(6) 今まで伸ばしたブロック$cs$に$c$をくっつけて、原点を$p_l$から$p_r$に並行移動させ、24パターン回転させてシルエットに収まる配置であったら$cs$ に $c$ を加えて$c$ の近傍を $s$ に積む。&lt;/p&gt;
&lt;p&gt;(7) 可能な限り (5) に戻ってブロックを延長する&lt;/p&gt;
&lt;p&gt;(8) ブロックが延長できなくなったら、(2) に戻って右の原点を選び直す。&lt;/p&gt;
&lt;p&gt;(9) 一番多くのブロックを伸ばせたパターンを確定させる。&lt;/p&gt;
&lt;p&gt;533,534,221,417点を獲得。かなりスコアが改善した！&lt;/p&gt;
&lt;h4 id=&#34;回転&#34;&gt;回転&lt;/h4&gt;
&lt;p&gt;ブロックの回転に対応するように、配置するセルを回転する方法を思い悩む。
ビジュアライザに同梱されているツールでは得点計算の際にブロックが同型であるか判定していのでそれを参考にしようと思ったが&lt;/p&gt;
&lt;p&gt;(1) 片方のブロックをx, y, zが0以上でかつ座標が一番小さくなるように並行移動する正規化をする&lt;/p&gt;
&lt;p&gt;(2) もう一方のブロックを回転させて(1)の正規化を行う、という処理を24回繰り返し、同じになるかを判定&lt;/p&gt;
&lt;p&gt;ということをやっていて、ブロックを構築する際にいちいち同じことをやっていたら無駄に計算が走りそう。&lt;/p&gt;
&lt;p&gt;サイコロを考えて、6つのうちどの面を上面にするか、及び上面を固定して回転させる方法が4通りあると考えると、回転方法は全部で24通りになるはず。
できれば回転の生成元をいくつか掛けるようなことをしないでダイレクトに移動先を求めたい。&lt;/p&gt;
&lt;p&gt;調べると次のような回答が出てきたので、&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/16452383/how-to-get-all-24-rotations-of-a-3-dimensional-array&#34;&gt;How to get all 24 rotations of a 3-dimensional array?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/33190042/how-to-calculate-all-24-rotations-of-3d-array&#34;&gt;How to calculate all 24 rotations of 3d array?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一つめの下の回答を参考にして回転を全て列挙。 &lt;a href=&#34;https://stackoverflow.com/a/70413438&#34;&gt;https://stackoverflow.com/a/70413438&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Coord&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Coord {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rotate&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self, t: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Self&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (x, y, z) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (self.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, self.&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, self.&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; t {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(x, y, z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, z, y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(x, z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, x, z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(y, x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(y, z, x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(z, x, y),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;z, y, x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(z, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;y, x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; Self(z, y, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;x),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; unreachable!(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;その後、最初の左側の点を選ぶ順番を乱数を変えて10回試すようにすると、331,122,522,183点に改善。
最後にサイズ1ブロック埋めでスコアが大きく変動するような構成なので点がブレやすいのかもしれない。&lt;/p&gt;
&lt;h3 id=&#34;2023327&#34;&gt;2023/3/27&lt;/h3&gt;
&lt;p&gt;多次元配列を一次元に直し、時間いっぱいまで乱数で粘るように修正。
123,723,204,167点とかなりの向上が見られた。&lt;/p&gt;
&lt;h3 id=&#34;2023329&#34;&gt;2023/3/29&lt;/h3&gt;
&lt;p&gt;大きいブロックとその他小さいブロック、のような組み合わせでスコアが伸びないように見えたので、
5, 10, 25, 50, 100, std::usize::MAX から最大サイズを決めて探索。&lt;/p&gt;
&lt;p&gt;ブロックの最大サイズと得点の関係は下のようになっていて明確な関係性は見られなかったが、スコアは91,182,918,858点に改善。
&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/ahc019-maxsize-0000.png&#34; alt=&#34;maxsize&#34;&gt;&lt;/p&gt;
&lt;p&gt;今まで常に限界まで探索していたが、サイズを小さくすることで、探索ごとの計算量が削減できイテレーション数を増やすことができたようだ。&lt;/p&gt;
&lt;h3 id=&#34;2023330&#34;&gt;2023/3/30&lt;/h3&gt;
&lt;p&gt;最大サイズは効果がありそうだったので、さらに多様性を作ろうと思い、乱数で最大サイズを動かして探索。
5〜(左と右で置ける場所の最大値)/2 から最大サイズをランダムに選ぶようにした。
70,758,817,150点に改善。&lt;/p&gt;
&lt;h3 id=&#34;202341&#34;&gt;2023/4/1&lt;/h3&gt;
&lt;p&gt;空間上の座標に対し、周囲6マスで配置できる場所が何箇所あるかを最初に計算し、
右のスペースで原点とする座標を周囲で配置できる場所から少ないものから優先して計算することにした。&lt;/p&gt;
&lt;p&gt;55,754,728,979点に改善。&lt;/p&gt;
&lt;h3 id=&#34;202342&#34;&gt;2023/4/2&lt;/h3&gt;
&lt;p&gt;伸び悩む。最大配置できる場所が大きい場合、イテレーション数が少なくなっていたため、適当に「置ける場所が100以上だった場合、最大捜索数の乱数の範囲を 5〜(左と右で置ける場所の最大値)/4 から選ぶように変更。&lt;/p&gt;
&lt;p&gt;シルエットで影で隠れている部分が大きいものに対しては少し効果あり。&lt;/p&gt;
&lt;p&gt;下のように、ブロックの数が多くなるほどスコアが悪化するため、なんとかブロックの数に制約がかけられないかと思ったが、上手い方法が思いつかない。
&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/ahc019-blocks-0000.png&#34; alt=&#34;blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;結局考察が伸ばせず、51,166,186,482点で終了。&lt;/p&gt;
&lt;h3 id=&#34;結果&#34;&gt;結果&lt;/h3&gt;
&lt;p&gt;プレテスト62位、システムテスト61位。トップ層の最終日の追い上げが凄まじく、一度は50位以内に入っていたもの最後の方は下がっていく順位を眺めていた。&lt;/p&gt;
&lt;h3 id=&#34;感想&#34;&gt;感想&lt;/h3&gt;
&lt;p&gt;焼きなましで解を磨きあげてスコアを伸ばしたかったが近傍の作り方がわからなかったのが反省点。&lt;/p&gt;
&lt;p&gt;ただスコアを見るだけでなく様々なデータを取って分析することが大事だと思った。
そろそろクラウドでテストケースを実行する環境を整えてテストを楽にしたい。&lt;/p&gt;
&lt;p&gt;今回思い出しながら参加記を書いたので、次からは参加しながらメモを取ろうと思う。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rustでインタラクティブの問題を解く</title>
      <link>https://matsueushi.github.io/atcoder/rust-interactive/</link>
      <pubDate>Sun, 18 Sep 2022 11:07:07 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/rust-interactive/</guid>
      <description>&lt;p&gt;RustでAtCoderのインタラクティブ問題の入出力方法がわからなかったのでメモ&lt;/p&gt;
&lt;p&gt;proconio クレートの &lt;code&gt;[fastout]&lt;/code&gt; は使わないで下のようにすれば良い。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::io::BufReader;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; proconio::{input, source::line::LineSource};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stdin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::io::stdin();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; source &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LineSource::new(BufReader::new(stdin));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    input&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        from &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; source,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        n: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;省略&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc269/submissions/34963751&#34;&gt;https://atcoder.jp/contests/abc269/submissions/34963751&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderで水色になりました</title>
      <link>https://matsueushi.github.io/atcoder/cyan/</link>
      <pubDate>Sun, 18 Sep 2022 09:48:50 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/cyan/</guid>
      <description>&lt;p&gt;UNICORNプログラミングコンテスト2022(AtCoder Beginner Contest 269)でAtCoder水色に上がりました。
&lt;a href=&#34;https://atcoder.jp/users/matsueushi&#34;&gt;https://atcoder.jp/users/matsueushi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;緑に上がった後にJuliaではなくRustを使い始めたので最初のうちは言語の違いに苦戦していました。
とはいえまだコレクションの扱いなどはいつもドキュメントや自分のメモを見返しながら実装しているので慣れたいですね。&lt;/p&gt;
&lt;p&gt;バーチャルコンテストなどはやっておらずAtCoderProblemsで緑diffの問題を中心に解くというやり方でした。
今後は水色維持・青色達成に向けてわからない問題の解説をしっかり読み込んでいこうと思います。&lt;/p&gt;
&lt;h3 id=&#34;課題だと思っているもの&#34;&gt;課題だと思っているもの&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;水、青diffで解いている問題数が純粋に少ない&lt;/li&gt;
&lt;li&gt;実装速度&lt;/li&gt;
&lt;li&gt;インタラクティブ問題: Rustで解いたことがなかったので、ABC269のコンテストにJuliaで慌てて解くことになりました&lt;/li&gt;
&lt;li&gt;mod計算のライブラリ&lt;/li&gt;
&lt;li&gt;Mo&amp;rsquo;s algorithm&lt;/li&gt;
&lt;li&gt;グラフアルゴリズム&lt;/li&gt;
&lt;li&gt;FFT&lt;/li&gt;
&lt;li&gt;ヒューリスティック: 全くやっていません。「&lt;a href=&#34;https://book.mynavi.jp/ec/products/detail/id=131288&#34;&gt;競技プログラミングの鉄則&lt;/a&gt;」を買ったので、挑戦してみたいです&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../green/&#34;&gt;AtCoderで緑色になりました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 268 C Chinese Restaurant</title>
      <link>https://matsueushi.github.io/atcoder/abc268c/</link>
      <pubDate>Sun, 11 Sep 2022 22:55:10 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc268c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc268/tasks/abc268_c&#34;&gt;https://atcoder.jp/contests/abc268/tasks/abc268_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;人 $i$ の前に料理 $p_i$ が置かれている場合、その皿だけ考えると、mod Nで考えて、
$i-p_i-1, i-p_i, i-p_i+1$ だけ料理をずらした時に幸福値が1増えてそれ以外だと幸福値は増えない。&lt;/p&gt;
&lt;p&gt;xs[i] = (テーブルをiだけずらした時の幸福数)&lt;/p&gt;
&lt;p&gt;としてxsを更新していけば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc268/submissions/34802426&#34;&gt;https://atcoder.jp/contests/abc268/submissions/34802426&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 181 F - Silver Woods</title>
      <link>https://matsueushi.github.io/atcoder/abc181-f/</link>
      <pubDate>Sat, 20 Aug 2022 11:55:41 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc181-f/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc181/tasks/abc181_f&#34;&gt;https://atcoder.jp/contests/abc181/tasks/abc181_f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$r$ を動かした時に、動かす円の中心が存在できない範囲を考えてみる。
壁もしくは障害物から距離 $r$ 未満の位置に円の中心を配置することができないことを考えると、動かせない範囲は下の青色で示した領域の内部になる。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/abc181-f-0.svg&#34; alt=&#34;fig0&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/abc181-f-1.svg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;p&gt;上の壁と下の壁が図で示した青色の領域を通じて繋がっていなければ円が通過でき、繋がっていれば円が通過できない。
繋がっているか繋がっていないかはUnionFindで判定できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$y=100$ と 釘 $(x_i, y_i)$ が繋がっている &amp;lt;=&amp;gt; $y_i + 2 r &amp;gt; 100$&lt;/li&gt;
&lt;li&gt;$y=-100$ と 釘 $(x_i, y_i)$ が繋がっている &amp;lt;=&amp;gt; $y_i - 2 r &amp;lt; 100$&lt;/li&gt;
&lt;li&gt;釘 $(x_i, y_i)$ と 釘 $(x_j, y_j)$ が繋がっている &amp;lt;=&amp;gt; $(x_i-x_j)^2 + (y_i-y_j)^2 &amp;lt; (2r)^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これで $r$ が与えられたときの判定方法がわかったので、あとは $r$ を二分探索する。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc181/submissions/34127397&#34;&gt;https://atcoder.jp/contests/abc181/submissions/34127397&lt;/a&gt; (Rust, 14ms)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tenka1 Programmer Contest C - Align</title>
      <link>https://matsueushi.github.io/atcoder/tenka1-2018-c/</link>
      <pubDate>Sun, 19 Jun 2022 21:07:30 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/tenka1-2018-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/tenka1-2018/tasks/tenka1_2018_c&#34;&gt;https://atcoder.jp/contests/tenka1-2018/tasks/tenka1_2018_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正の整数からなる数列 $\{A_i\}_i$ が与えられた時に、
数列を自由に並び替えた時の隣り合う要素の差の合計の最大値を求めよ、という問題。&lt;/p&gt;
&lt;p&gt;大小関係がジグザグにすれば良い、ということはなんとなくわかったが、
解説を読んでもピンと来なかったので整理しておく。&lt;/p&gt;
&lt;p&gt;まず、$A_i$ はソートされていると考えて良いだろう。すると、次のような問題を考えれば良いことになる。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/tenka1-2018-fig1.svg&#34; alt=&#34;fig1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数直線の上に $\{A_i\}_i$ が並んでいる。始点と終点を異なるように選び、全ての点を一回ずつ通って進む。移動距離の最大値を求めよ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$A_i$ と $A_{i+1}$ が作る区間を $I_i$ とし、その長さを $B_i = A_{i+1}-A_i$ とおく。
上の図だと、$A_1$ から $A_5$ まで点があり、区間が $I_1$ から $I_4$ まである。&lt;/p&gt;
&lt;h3 id=&#34;始点終点の場合を考えてみる&#34;&gt;始点=終点の場合を考えてみる&lt;/h3&gt;
&lt;p&gt;脱線するが、最初に始点 = 終点 となる場合の変種を考える。&lt;/p&gt;
&lt;p&gt;それぞれの区間を通過する最大回数を考える。
$I_1$ から順番に考えていくと、$I_1$ を通過するのは $A_1$ から出ていく時か、$A_1$ に入る時の高々2回しかない。
$I_2$ を考えると、 $I_1$ で考えた $A_1$ から出ていく矢印、 $A_1$ に戻る矢印がそのまま2を通過する場合と、
新たに $A_2$ に出入りする矢印がある場合の高々4通りである。&lt;/p&gt;
&lt;p&gt;このように考え、さらに左右の対称性も考慮すると、区間 $I_i$ を通過する回数は、最大 $2\min (i, n-i)$ 回であることがわかる。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/tenka1-2018-fig2.svg&#34; alt=&#34;fig2&#34;&gt;&lt;/p&gt;
&lt;p&gt;また、この最大値をとるような動き方は、上の図のようにジグザグに移動することで必ず達成でき、
$2\sum_{i=1}^{n-1} \min (i, n-i) B_i$ が移動距離の最大値であることがわかる。&lt;/p&gt;
&lt;h3 id=&#34;始点と終点が異なる場合&#34;&gt;始点と終点が異なる場合&lt;/h3&gt;
&lt;p&gt;始点と終点が異なる場合、移動距離 $2\sum_{i=1}^{n-1} \min (i, n-i) B_i$ は達成できない。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/tenka1-2018-fig3.svg&#34; alt=&#34;fig3&#34;&gt;&lt;/p&gt;
&lt;p&gt;しかし、上のようにジグザグに動くことを考えると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$n = 2m-1$, 奇数の場合 : $2\sum_{i=1}^{n-1} \min (i, n-i) B_i - B_{m-1}$ や $2\sum_{i=1}^{n-1} \min (i, n-i) B_i - B_m$&lt;/li&gt;
&lt;li&gt;$n = 2m$, 偶数の場合 : $2\sum_{i=1}^{n-1} \min (i, n-i) B_i - B_m$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;は達成できることがわかる。それぞれ始点、終点の位置の集合は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$n = 2m-1$, 奇数の場合 : $\{A_{m-1},A_m\}$ または $\{A_m,A_{m+1}\}$&lt;/li&gt;
&lt;li&gt;$n = 2m$, 偶数の場合 : $\{A_m,A_{m+1}\}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と中央の位置にある場合になる。始点と終点が一致する時の通過回数の最大回数に比べ、通過回数の差は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$n = 2m-1$, 奇数の場合 : $I_{m-1}$ または $I_m$ が1回少なく通過&lt;/li&gt;
&lt;li&gt;$n = 2m$, 偶数の場合 :  $I_m$ が1回少なく通く&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区間を通過する回数を始点=終点の時と同様に考えると、それ以外の位置に始点、終点がある場合通過区間の通過した回数が少なくなることがわかる。(最適な始点・終点の位置より外側に配置すると通過できない回数が増え、上に挙げたいずれかの場合よりも距離が短くなる)&lt;/p&gt;
&lt;p&gt;結局、ジグザグに動く時が最適になり、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$n = 2m-1$, 奇数の場合 : $2\sum_{i=1}^{n-1} \min (i, n-i) B_i - \min (B_{m-1},B_m)$&lt;/li&gt;
&lt;li&gt;$n = 2m$, 偶数の場合 : $2\sum_{i=1}^{n-1} \min (i, n-i) B_i - B_m$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が答えになることがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/tenka1-2018/submissions/32590060&#34;&gt;https://atcoder.jp/contests/tenka1-2018/submissions/32590060&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>全国統一プログラミング王決定戦予選 C - Different Strokes</title>
      <link>https://matsueushi.github.io/atcoder/nikkei2019-qual-c/</link>
      <pubDate>Tue, 14 Jun 2022 22:55:50 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/nikkei2019-qual-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_c&#34;&gt;https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2人が最適な戦略を取るとき、残っている料理のうち $A_i+B_i$ が最大となるものを交互に選んでいくことになることを示す。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3
20 10
20 20
20 30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;この入力の場合を考える。&lt;/p&gt;
&lt;p&gt;Aの立場で考えてみよう。
全部相手に料理を食べられてしまった時の自分から見た幸福度の差は、$-B_1-B_2-B_3$ である。料理 $i$ を食べると、この値が $A_i+B_i$ 改善することがわかる。そのため、Aの立場で考えると $A_i+B_i$ が大きいものを優先して食べたいことがわかる。&lt;/p&gt;
&lt;p&gt;次にBの立場で考えてみると、同じように $A_i+B_i$ が大きいものを優先するのが最適解であることが同様の議論でわかる。
A も B も料理 $i$ を食べるとそれぞれの立場で見た幸福度の差が $A_i+B_i$ 改善するため、$A_i+B_i$ と書かれた $N$ 個の料理を合計の数値が最大となるよう二人で交互に取り合っているのと同値な状況とみなせる。&lt;/p&gt;
&lt;p&gt;$A_i+B_i$ を降順にソートし、奇数番目を高橋くん、偶数番目を青木さんが選んだとして幸福度の差を計算すればOK。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/nikkei2019-qual/submissions/32474436&#34;&gt;https://atcoder.jp/contests/nikkei2019-qual/submissions/32474436&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 121 D - XOR World</title>
      <link>https://matsueushi.github.io/atcoder/abc121-d/</link>
      <pubDate>Tue, 14 Jun 2022 21:31:14 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc121-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc121/tasks/abc121_d&#34;&gt;https://atcoder.jp/contests/abc121/tasks/abc121_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ビットごとの排他的論理和は二回繰り返すと元に戻り、可換で結合法則を満たすことから、&lt;/p&gt;
&lt;p&gt;$f(A,B)=A \veebar A+1 \veebar \cdots \veebar B = (0 \veebar 2 \veebar \cdots \veebar A-1) \veebar (0 \veebar 2 \veebar \cdots \veebar B) = f(1,A-1) \veebar f(1,B)$&lt;/p&gt;
&lt;p&gt;だから、$A=0$ の場合に帰着される。&lt;/p&gt;
&lt;p&gt;それぞれの桁毎に、$0~B$ に出てくる $1$ の数が偶数個か奇数個か数えれば、$f(1,B)$ の各ビットがわかる。 $A=0$ の $1,2,3,&amp;hellip;$ のビット表示を確認すると、&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;10進数&lt;/th&gt;
&lt;th&gt;2進数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00000001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;00000010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;00000011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;00000100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$1$ の位は $0 \rightarrow 1 \rightarrow 0  \rightarrow 1 \rightarrow \cdots$ と1つごとに切り替わり、 $2$ の位は $0 \rightarrow 0 \rightarrow 1 \rightarrow 1 \rightarrow \cdots$ と2つ毎に切り替わり、と規則的になっている。&lt;/p&gt;
&lt;p&gt;$2^i$ 桁目のビットを考えよう。$i=0$ の時は $B \equiv 1 \mod 4$ なら $1$, それ以外なら $0$ が立っている。&lt;/p&gt;
&lt;p&gt;$i \ge 1$ であれば、$2^{i+1}$ 毎に $1$ が $2^i$ 個(偶数個)出てくるから、$1$ の出現数の偶奇は $(B+1) \mod 2^{i+1}$ で考えれば良い。
$2^{i+1}$ 個ごとの $0/1$ の出現順は、最初に $0$ が $2^i$ 個続き、そのあと $1$ が $2^i$ 個続くから、 $1$ の数は、$\max(0, ((B+1) \mod 2^{i+1}) - 2^i)$。
この数が偶数なら $0$, 奇数なら $1$ のビットが立っている。&lt;/p&gt;
&lt;p&gt;(実装は結構手間取りました)
&lt;a href=&#34;https://atcoder.jp/contests/abc121/submissions/32474342&#34;&gt;https://atcoder.jp/contests/abc121/submissions/32474342&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 147 D - Xor Sum 4</title>
      <link>https://matsueushi.github.io/atcoder/abc147-d/</link>
      <pubDate>Mon, 13 Jun 2022 21:39:24 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc147-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc147/tasks/abc147_d&#34;&gt;https://atcoder.jp/contests/abc147/tasks/abc147_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;もちろん素朴に計算していては間に合わないが、ビット毎に考えれば良い。&lt;/p&gt;
&lt;p&gt;$z_i = 1 \ll i$ とおくと、任意の $x$ に対して $x = \sum_i x \&amp;amp; z_i$ であり、
$(x \oplus y) \&amp;amp; z_i = (x \&amp;amp; z_i )\oplus (y \&amp;amp; z_i)$ である。&lt;/p&gt;
&lt;p&gt;$\sum_{i=1}^{N-1} \sum_{j=i+1}^N (A_i \oplus A_j) = \sum_k \sum_{i=1}^{N-1} \sum_{j=i+1}^N ((A_i \&amp;amp; z_k) \oplus (A_j \&amp;amp; z_k))$
であり、右のように変形すると、$A_i \&amp;amp; z_k = 0$ または $z_k$ であるので計算が簡単にできる。&lt;/p&gt;
&lt;p&gt;$B_k = \#\{ i \mid A_i \&amp;amp; z_k = 0 \}, C_k = \#\{ i \mid A_i \&amp;amp; z_k = z_k \}$ とおくと、
$(A_i \&amp;amp; z_k) \oplus (A_j \&amp;amp; z_k)$ は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$0 \oplus 0 = 0$&lt;/li&gt;
&lt;li&gt;$0 \oplus z_k = z_k$&lt;/li&gt;
&lt;li&gt;$z_k \oplus 0 = z_k$&lt;/li&gt;
&lt;li&gt;$z_k \oplus z_k = 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の4通りなので、
$\sum_{i=1}^{N-1} \sum_{j=i+1}^N ((A_i \&amp;amp; z_k) \oplus (A_j \&amp;amp; z_k)) = B_k * C_k * z_k$ である。
あとはこれを $k$ について足し合わせる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc147/submissions/32456970&#34;&gt;https://atcoder.jp/contests/abc147/submissions/32456970&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder AGC 023 A - Zero-Sum Ranges</title>
      <link>https://matsueushi.github.io/atcoder/agc023-a/</link>
      <pubDate>Mon, 13 Jun 2022 21:26:12 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/agc023-a/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc023/tasks/agc023_a&#34;&gt;https://atcoder.jp/contests/agc023/tasks/agc023_a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$C_j = \sum_{k=1}^j A_k$ とおくと、 $\sum_{k=i}^j A_k = 0 \Leftrightarrow C_j = C_{k-1}$ であるから、
累積和を求めて $C_0=0, C_j = \sum_{k=1}^j A_k$ とおき、 $I_x = \{ i \mid C_i = x\}$ を計算して、$\sum_x |I_x| (|I_x|-1)/2$ を求めれば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc023/submissions/32455933&#34;&gt;https://atcoder.jp/contests/agc023/submissions/32455933&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 255 C - ±1 Operation 1 </title>
      <link>https://matsueushi.github.io/atcoder/abc255-c/</link>
      <pubDate>Sun, 12 Jun 2022 21:11:31 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc255-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/tasks/abc255_c&#34;&gt;https://atcoder.jp/contests/abc255/tasks/abc255_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$\min_{i=0,\ldots,n-1}|A+Di-X|$ を求めれば良い。$y=A+Dx$ と $y=X$ の交点を求め、
$x &amp;lt; 0, 1 \le x \le n-1 ,x &amp;gt; n-1$ の場合に応じて計算すれば良い。&lt;/p&gt;
&lt;p&gt;$|A+Di-X|$ が最も小さくなるのは、$x$ に最も近い $0\le i \le n-1$ を選んだ時である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/submissions/32387318&#34;&gt;https://atcoder.jp/contests/abc255/submissions/32387318&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 255 D - ±1 Operation 2</title>
      <link>https://matsueushi.github.io/atcoder/abc255-d/</link>
      <pubDate>Sun, 12 Jun 2022 21:11:31 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc255-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/tasks/abc255_d&#34;&gt;https://atcoder.jp/contests/abc255/tasks/abc255_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$i$ を一つ固定した時、操作の最低回数は $\sum_{j=1}^N |A_j-X_i|$ である。&lt;/p&gt;
&lt;p&gt;$A_k$ の順番は関係ないので、 $A_k$ は昇順にソートしているとして良い。$A_k$ をソートするのは最初に一回だけやれば良い。&lt;/p&gt;
&lt;p&gt;累積和 $C_k = \sum_{j=1}^k A_j$ を使って  $S = \sum_{j=1}^N |A_j-X|$ を次のように求める。
$l = \max \{ j \mid A_j \le X\}$ とすると $S = (lX - C_l) + ((C_N-C_l) - (N-l)X)$ となる。&lt;/p&gt;
&lt;p&gt;$A = [1,2,4,5], X=3$ の時、求めたいのは下の赤と青の面積で、&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://matsueushi.github.io/images/atcoder/abc255-d.svg&#34; alt=&#34;hist&#34;&gt;&lt;/p&gt;
&lt;p&gt;$l = 2$ で赤色の部分が $lX - C_l$, 青色の部分が $(C_N-C_l) - (N-l)X$ に対応。&lt;/p&gt;
&lt;p&gt;各クエリに対して2分探索するところで $O(\log N)$ 時間かかるので、$O(Q\log N)$ で全てのクエリを処理できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/submissions/32393722&#34;&gt;https://atcoder.jp/contests/abc255/submissions/32393722&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 255 E - Lucky Numbers</title>
      <link>https://matsueushi.github.io/atcoder/abc255-e/</link>
      <pubDate>Sun, 12 Jun 2022 21:11:31 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc255-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/tasks/abc255_e&#34;&gt;https://atcoder.jp/contests/abc255/tasks/abc255_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$A_1 = \alpha$ とおくと、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A_2 = S_1 - A_1 = S_1 - \alpha$&lt;/li&gt;
&lt;li&gt;$A_3 = S_2 - A_2 = S_2 - S_1 + \alpha$
&amp;hellip;
となることがわかる。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$T_1 = 0, T_k = \sum_{i=1}^{k-1} (-1)^{i+k+1}S_k$ とおくと、どんな $A$ に対しても、 ある $\alpha$ が存在して $A_k = T_k + (-1)^{k+1} \alpha$ が全ての $k$ に対して成り立つことがわかる。&lt;/p&gt;
&lt;p&gt;$F(i,\alpha) = |\{ k \mid  T_k + (-1)^{k+1} \alpha = X_i \} |$ とする。
これは、 $i, \alpha$ に対して、$X_i = T_k + (-1)^{k+1} \alpha$ となる $k$ を数えていることになる。$T, X$ の条件から $F(i,\alpha) \neq 0$ となる $\alpha$ は絞り込むことができる。&lt;/p&gt;
&lt;p&gt;あとは、$i$ を動かして $\sum_i F(i,\alpha)$ の最大値を取れば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc255/submissions/32403143&#34;&gt;https://atcoder.jp/contests/abc255/submissions/32403143&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder diverta 2019 Programming Contest D - DivRem Number</title>
      <link>https://matsueushi.github.io/atcoder/diverta2019-d/</link>
      <pubDate>Sat, 11 Jun 2022 19:45:34 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/diverta2019-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/diverta2019/tasks/diverta2019_d&#34;&gt;https://atcoder.jp/contests/diverta2019/tasks/diverta2019_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$t = \lfloor n/m\rfloor = n \mod m$ とおくと $0 \le t &amp;lt; m$であり、$n=\alpha m + t$ とおける。
$t$ の条件から $\alpha = \lfloor n/m\rfloor = t$ だから結局 $n = t(m+1)$ とかける。&lt;/p&gt;
&lt;p&gt;$n = t(m+1) \ge t^2$ より、$t \le \sqrt{n}$ を探索すれば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/diverta2019/submissions/32371542&#34;&gt;https://atcoder.jp/contests/diverta2019/submissions/32371542&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder APC 001 B - Two Arrays</title>
      <link>https://matsueushi.github.io/atcoder/apc001-b/</link>
      <pubDate>Fri, 10 Jun 2022 08:35:23 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/apc001-b/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/apc001/tasks/apc001_b&#34;&gt;https://atcoder.jp/contests/apc001/tasks/apc001_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$c_i = a_i - b_i$ とする。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3
1 2 3
5 2 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;であれば $c = [-4,0,1]$ となる。 目的は、全ての $i$ に対して $c_i = 0$ とすること。&lt;/p&gt;
&lt;p&gt;$a_i$ に $2$ を足し、$b_i$ に $1$ を足す操作は、$i=j$ であれば $c_i$ に $1$ を足し(操作1とする）、
$i \neq j$ ならば $c_i$ に $2$ を足し、$c_j$ から $1$ を引く操作(操作2とする)に対応する。
数字を減らすのは操作2でしか行えないことに注意。&lt;/p&gt;
&lt;p&gt;$c_i$ を非負の部分と負の部分に分け、
$I_+ = \{ i \mid c_i ≥ 0\}, I_- = \{ i \mid c_i &amp;lt; 0 \}$,
$S = \sum_{i \in I+} c_i, V = \sum_{i \in I-}\lfloor |c_i|/2 \rfloor$ とおく。&lt;/p&gt;
&lt;p&gt;$S$ は、操作2を行わなくてはいけない最低回数、$V$ は $0$ を超えないようにマイナスになっている $c_i$ に $2$ を足すことのできる最大回数とも考えられる。&lt;/p&gt;
&lt;p&gt;操作1で任意の場所の数字を任意の数だけ増やせるので、$I_+ = \empty$ つまり $S=0$ の状態にできれば良い。&lt;/p&gt;
&lt;p&gt;操作1 または 操作2 で $S$ を減らすことを考える。&lt;/p&gt;
&lt;p&gt;操作2で、$c_i \le -2, c_j &amp;gt; 0$ となっている $i,j$ を選んで $c_i$ に $+2$, $c_j$ に $-1$ すること(操作☆と呼ぶ)でしか $S$ は減らせないことがわかる。
この時、$S、V$ がともに1減少する。&lt;/p&gt;
&lt;p&gt;それ以外のパターンを考えると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作1 -&amp;gt; $c_i \ge 0$ なら $S$ が1増加、それ以外なら $V$ が0または1減少&lt;/li&gt;
&lt;li&gt;操作2 -&amp;gt; $+2$ する操作により、 $S$ が 1以上増加するか $V$ が1減少する。$c_j \le 0$ の時、$-1$ する操作では $V$ を高々1しか増やせない。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上により、どう頑張っても $V$ を増やすことはできないことがわかる。&lt;/p&gt;
&lt;p&gt;$S ≤ V$ ならば、$c_i \le -2, c_j &amp;gt; 0$ となっている $i,j$ を選んで操作☆を続けることで $S=0$ とできる。
それ以外ならどう頑張っても $S$ 回上のような操作ができないので、目的が達成できない。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/apc001/submissions/32369370&#34;&gt;https://atcoder.jp/contests/apc001/submissions/32369370&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 198 D - Send More Money</title>
      <link>https://matsueushi.github.io/atcoder/abc198-d/</link>
      <pubDate>Tue, 07 Jun 2022 23:42:09 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc198-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc198/tasks/abc198_d&#34;&gt;https://atcoder.jp/contests/abc198/tasks/abc198_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;覆面算を解く問題。Send More Moneyって何？と思ったのですが &lt;code&gt;SEND + MORE = MONEY&lt;/code&gt; という覆面算が有名らしいです。&lt;/p&gt;
&lt;p&gt;戦略としては、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S_1, S_2, S_3&lt;/code&gt; に出てくる文字の集合を作る。10種類以上出てきたら &lt;code&gt;UNSOLVABLE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;先ほど文字の集合に番号をつける。順番はどうでもいい。&lt;code&gt;[&#39;v&#39;, &#39;f&#39;, &#39;c&#39;]&lt;/code&gt; だったら v = 1番目、f = 2番目、のような対応づけをする。&lt;/li&gt;
&lt;li&gt;これにより、&lt;code&gt;S_1, S_2, S_3&lt;/code&gt; が &lt;code&gt;[3,5,1], [1,4,2], [2,2,2]&lt;/code&gt; のような 1~10の整数の数列に変換できる。&lt;/li&gt;
&lt;li&gt;あとは 1~10番目の文字に対して 0~9 の数字をどのように当てはめるか全探索。
全探索しても10!=3628800通りなので間に合う。
Julia だと C++ における &lt;a href=&#34;https://www.cplusplus.com/reference/algorithm/next_permutation/&#34;&gt;&lt;code&gt;std::next_permutaiton&lt;/code&gt;&lt;/a&gt; が標準ライブラリに無い(存在を知らない) ので自分で作る必要がありますね。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc198/submissions/32308692&#34;&gt;https://atcoder.jp/contests/abc198/submissions/32308692&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 129 D - Lamp</title>
      <link>https://matsueushi.github.io/atcoder/abc129-d/</link>
      <pubDate>Tue, 07 Jun 2022 22:27:13 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc129-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc129/tasks/abc129_d&#34;&gt;https://atcoder.jp/contests/abc129/tasks/abc129_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;水平方向、垂直方向にそれぞれ見て行った時に、&amp;rsquo;#&amp;rsquo;, &amp;lsquo;.&amp;lsquo;の連続数を並べた数列を作る。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#..#..
.....#
....#.
#.#...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;であったら&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
    [1, 2, 1, 2],
    [5, 1],
    [4, 1, 1],
    [1, 1, 1, 3],
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;さらにこれの累積和をとると、&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
    [1, 3, 4, 6],
    [5, 6],
    [4, 5, 6],
    [1, 2, 3, 6],
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;となり、&lt;code&gt;(3,4)&lt;/code&gt;に置いた光が横方向にどれくらい届くか調べたかったら、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(3,4)&lt;/code&gt; が &amp;lsquo;.&amp;rsquo; であるかを調べる&lt;/li&gt;
&lt;li&gt;3行目の累積和 &lt;code&gt;[4, 5, 6]&lt;/code&gt;を見て、4番目を超えている場所のインデックスを探す(この場合は1番目)&lt;/li&gt;
&lt;li&gt;累積和を取る前の &lt;code&gt;[4, 1, 1]&lt;/code&gt; の対応する場所を見れば、横方向に連続している白マスがカウントできる。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;垂直方向も同様にカウントできる。&lt;code&gt;(横方向の連続数)+(縦方向の連続数)-1&lt;/code&gt; を白マスで計算してmaxを取れば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc129/submissions/32307404&#34;&gt;https://atcoder.jp/contests/abc129/submissions/32307404&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 153 E - Crested Ibis vs Monster</title>
      <link>https://matsueushi.github.io/atcoder/abc153-e/</link>
      <pubDate>Mon, 06 Jun 2022 22:06:55 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc153-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/tasks/abc153_e&#34;&gt;https://atcoder.jp/contests/abc153/tasks/abc153_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(dp[i][k]\) = \(i\) 番目までの魔法からダメージが \(k\) 以上になるように選んだ時に消費するMPの最小値&lt;/p&gt;
&lt;p&gt;とすると、個数制限なしナップザック問題（の類似）に帰着される。
(参考:蟻本の2章 p.p.58 漸化式を工夫する)&lt;/p&gt;
&lt;p&gt;\(dp[i+1][k] = \min(dp[i][k], dp[i+1][k-a[i]]+b[i])\)&lt;/p&gt;
&lt;p&gt;である。ここで、\(dp[-1][k] = 0\) と \(dp[i][k] = 0 \ (k &amp;lt; 0)\) とおいた。&lt;/p&gt;
&lt;p&gt;答えは \(dp[n][h]\) であり、\(O(nh)\) で求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/submissions/32290815&#34;&gt;https://atcoder.jp/contests/abc153/submissions/32290815&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 161 D - Lunlun Number</title>
      <link>https://matsueushi.github.io/atcoder/abc161-d/</link>
      <pubDate>Sun, 05 Jun 2022 21:16:30 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc161-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc161/tasks/abc161_d&#34;&gt;https://atcoder.jp/contests/abc161/tasks/abc161_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;桁数の少ないルンルン数から順に作っていけば良い。&lt;/p&gt;
&lt;p&gt;1桁のルンルン数 = 1,2,&amp;hellip;,9&lt;/p&gt;
&lt;p&gt;2桁のルンルン数 = ([1 桁のルンルン数][最後の数字に-1,0,+1のどれかを足したもの]の順に繋げた数)&lt;/p&gt;
&lt;p&gt;3桁のルンルン数 = ([2 桁のルンルン数][最後の数字に-1,0,+1のどれかを足したもの]の順に繋げた数)&lt;/p&gt;
&lt;p&gt;このように考えていくと、自然にルンルン数が昇順に列挙できる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc161/submissions/32271070&#34;&gt;https://atcoder.jp/contests/abc161/submissions/32271070&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder CODE FESTIVAL 2017 qualC C - Inserting &#39;x&#39;</title>
      <link>https://matsueushi.github.io/atcoder/code-festival-2017-qualc-d/</link>
      <pubDate>Sun, 05 Jun 2022 18:08:29 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/code-festival-2017-qualc-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/code-festival-2017-qualc/tasks/code_festival_2017_qualc_c&#34;&gt;https://atcoder.jp/contests/code-festival-2017-qualc/tasks/code_festival_2017_qualc_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目標が達成可能かどうかは、s から &amp;lsquo;x&amp;rsquo; を取り除いてできる文字列が回文であるかどうかで判定できる。
以後、目標が達成可能な場合を考える。&lt;/p&gt;
&lt;p&gt;s の &amp;lsquo;x&amp;rsquo; でない文字列のうち左から i 番目の文字を \(cs[i]\) とする。(i = 1,&amp;hellip;,m とする)&lt;/p&gt;
&lt;p&gt;\(ds[i]\) を \(cs[i]\) と \(cs[i+1]\) の間にある &amp;lsquo;x&amp;rsquo; の個数とする。
\(ds[0]\) を \(cs[1]\) の前にある &amp;lsquo;x&amp;rsquo; の数、\(ds[m]\) を \(cs[m]\) の後にある &amp;lsquo;x&amp;rsquo; の数と拡張しておく。&lt;/p&gt;
&lt;p&gt;s = &amp;ldquo;xabxa&amp;rdquo; の時は、cs = [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;a&amp;rsquo;], ds = [1,0,1,0]である。&lt;/p&gt;
&lt;p&gt;&amp;lsquo;x&amp;rsquo; を挿入する操作は、ds の一つの数字を +1 することに相当する。ds が左右対称となった時文字列が回文になるから、
答えは l = length(ds) として \(\sum_{i=1}^{\lfloor l/2 \rfloor}|ds[i] - ds[l-i+1]| \) で求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/code-festival-2017-qualc/submissions/32267860&#34;&gt;https://atcoder.jp/contests/code-festival-2017-qualc/submissions/32267860&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 034 A - Kenken Race</title>
      <link>https://matsueushi.github.io/atcoder/agc034-a/</link>
      <pubDate>Sat, 04 Jun 2022 18:32:50 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/agc034-a/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/tasks/agc034_a&#34;&gt;https://atcoder.jp/contests/agc034/tasks/agc034_a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;すぬけくんしかいない場合を考えると、a地点からc地点に到達できる条件は、\([a,c]\)の間に連続する黒マスがないこと、である。&lt;/p&gt;
&lt;p&gt;2人いる場合を考えると、\(c&amp;lt;d \) の場合は、すぬけくんとふぬけくんの順序を入れ替える必要がないから、
ふぬけくんに先にゴースさせて、すぬけくんがその後ゴールすれば良い。
よって、一人だけの場合の条件をすぬけくん、ふぬけくんでそれぞれ考える。&lt;/p&gt;
&lt;p&gt;\(c &amp;gt; d \) の場合、順序を入れ替える必要がある。順序が入れ替わるのは、&lt;/p&gt;
&lt;p&gt;(す)(ふ)(空)&lt;/p&gt;
&lt;p&gt;という状態になっている時だから、ふぬけくんの現在いる位置、またはそれより右側で、前後が白マスになっているところを探す。
つまり、三連続で白マスになっている場所を探す。&lt;/p&gt;
&lt;p&gt;この時、候補の中で1番左の位置にある三連続白マスを考えれば良い。(状態が実現できなければ、それより右の三連続白マスで実現することは不可能のため)&lt;/p&gt;
&lt;p&gt;後は、&lt;/p&gt;
&lt;p&gt;(す)(ふ)(空)&lt;/p&gt;
&lt;p&gt;の状態に到達できるか確認して、到達できれば、順番を入れ替える必要がない\(c &amp;lt; d \)の場合に帰着できる。
この時、当初の目的地を飛び越えていないかもチェックする。
到達できなければ、実現不可能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/submissions/32194980&#34;&gt;https://atcoder.jp/contests/agc034/submissions/32194980&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder AGC 011 B - Colorful Creatures</title>
      <link>https://matsueushi.github.io/atcoder/agc011-b/</link>
      <pubDate>Thu, 02 Jun 2022 23:12:47 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/agc011-b/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc011/tasks/agc011_b&#34;&gt;https://atcoder.jp/contests/agc011/tasks/agc011_b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(A_i\) を降順にソートしても一般性を失わない。&lt;/p&gt;
&lt;p&gt;大きいものの方が吸収しづらいから、1番最後に\(1\), その前に \(2, \ldots, \)を吸収したとして良い。
\(A_1, \ldots, A_i\) を吸収するのに必要な最小のとなる生き物の大きさの整数値を \(B_i\) とする。&lt;/p&gt;
&lt;p&gt;\(B_1 = \lceil A_1 / 2\rceil \) である。
\(A_i\) が吸収でき、さらにその後 \(i-1, \ldots, 1\) が吸収できる条件を考えると、
\(B_i = \max(\lceil A_i / 2 \rceil, B_{i-1}-A_i)\) である。&lt;/p&gt;
&lt;p&gt;各 \(i \) に対し、\(i\) は \(i+1\) 以降を吸収できるから、\( \sum_{k=i}^n A_k \ge B_{i-1} \) を満たすかどうか判定すれば良い。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc011/submissions/32165993&#34;&gt;https://atcoder.jp/contests/agc011/submissions/32165993&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 134 D - Preparing Boxes</title>
      <link>https://matsueushi.github.io/atcoder/abc134-d/</link>
      <pubDate>Wed, 01 Jun 2022 22:16:01 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc134-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/tasks/abc134_d&#34;&gt;https://atcoder.jp/contests/abc134/tasks/abc134_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;条件を満たすボールの入れ方は、一意に定まる。&lt;/p&gt;
&lt;p&gt;n = 4 の場合、4 までに 3, 4 の倍数は一つしかないので、
| | |X|X|
a_3, a_4 の情報から i = 3,4 のボールの個数が確定する。&lt;/p&gt;
&lt;p&gt;次に、a_2 の情報から i = 2 のボールの個数が確定する。最後に i = 1 が確定する。&lt;/p&gt;
&lt;p&gt;このように考えると、第 k ステップで i ≥ floor(n/2^k) の場所のボールの個数が確定することがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/submissions/32148310&#34;&gt;https://atcoder.jp/contests/abc134/submissions/32148310&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 064 D - Insertion</title>
      <link>https://matsueushi.github.io/atcoder/abc064-d/</link>
      <pubDate>Tue, 31 May 2022 22:18:08 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc064-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/tasks/abc064_d&#34;&gt;https://atcoder.jp/contests/abc064/tasks/abc064_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先頭に&amp;quot;(&amp;quot;, 末尾に&amp;quot;)&amp;ldquo;を繋げて括弧列を作るのが辞書式最小となる。
(そのような作り方をしないと、より左の位置に&amp;rdquo;)&amp;ldquo;が出現する)&lt;/p&gt;
&lt;p&gt;&amp;ldquo;(&amp;rdquo; -&amp;gt; +1, &amp;ldquo;)&amp;rdquo; -&amp;gt; -1 と文字列を置き換えて累積和を取ったものを c[i] とすると、
c[i] ≥ 0 (1≤i≤n-1), c[n] = 0 が括弧列を成立させる条件である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/submissions/32131694&#34;&gt;https://atcoder.jp/contests/abc064/submissions/32131694&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 133 D - Rain Flows into Dams</title>
      <link>https://matsueushi.github.io/atcoder/abc133-d/</link>
      <pubDate>Tue, 31 May 2022 21:40:17 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc133-d/</guid>
      <description>&lt;p&gt;山 i に降った雨の量を \(2 * x_i\) とすると、\(\sum A_i = 2 \sum x_i\) だから、\(x_i\) の合計がわかる。&lt;/p&gt;
&lt;p&gt;Nが奇数であることから \(A_i = x_i + x_{i+1}\) をうまく足して \(\sum_{i \neq j} x_i\) が作れ、合計から引くことで \(x_j\) が求められる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc133/submissions/32131263&#34;&gt;https://atcoder.jp/contests/abc133/submissions/32131263&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 094 C - Many Medians</title>
      <link>https://matsueushi.github.io/atcoder/abc094-c/</link>
      <pubDate>Mon, 30 May 2022 23:21:40 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc094-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc094/tasks/arc095_a&#34;&gt;https://atcoder.jp/contests/abc094/tasks/arc095_a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まず、具体例で考えてみる。aがソートされている場合を考えよう。&lt;/p&gt;
&lt;p&gt;1,2,3,4,5&lt;/p&gt;
&lt;p&gt;で左からi番目の数を取り除いた中央値を考えると&lt;/p&gt;
&lt;p&gt;3,3,2,2,2&lt;/p&gt;
&lt;p&gt;となる。&lt;/p&gt;
&lt;p&gt;1,2,2,3&lt;/p&gt;
&lt;p&gt;であれば&lt;/p&gt;
&lt;p&gt;2,2,2&lt;/p&gt;
&lt;p&gt;である。&lt;/p&gt;
&lt;p&gt;よって、pos = floor((l+1)/2), 取り除かれた値をxとすると、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;l が偶数の時&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;x ≤ a[pos] -&amp;gt; 取り除いた後は a[pos+1] が中央値&lt;/li&gt;
&lt;li&gt;x &amp;gt; a[pos] -&amp;gt; a[pos]&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;l が奇数の時&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;x &amp;lt; a[pos] -&amp;gt; a[pos]&lt;/li&gt;
&lt;li&gt;x ≥ a[pos] -&amp;gt; a[pos-1]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;であることがわかる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc094/submissions/32115333&#34;&gt;https://atcoder.jp/contests/abc094/submissions/32115333&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 183 E - Queen on Grid</title>
      <link>https://matsueushi.github.io/atcoder/abc183-e/</link>
      <pubDate>Mon, 30 May 2022 23:05:11 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc183-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/tasks/abc183_e&#34;&gt;https://atcoder.jp/contests/abc183/tasks/abc183_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;まず1次元で右にしか進めない場合を考える。
dp[i]=左からi番目に移動する方法
とする。&lt;/p&gt;
&lt;p&gt;dp[i]=2^(n-1)である。1,…,i-1それぞれで立ち止まるか通過するか選べると考えてもいいが、dp[1]=1であり、i番目にいる時、移動をそこでやめてそこで立ち止まってi+1に進むか、そのまま移動してi+1に行くかの2通りがあるので、dp[i+1]=2*dp[i]であると考えられる。&lt;/p&gt;
&lt;p&gt;2次元にすると、向きが変わる場合があるので&lt;/p&gt;
&lt;p&gt;各マスでの状態を&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;右向きで進んでいる&lt;/li&gt;
&lt;li&gt;下向きに進んでいる&lt;/li&gt;
&lt;li&gt;斜め右下向きに進んでいる&lt;/li&gt;
&lt;li&gt;立ち止まっている&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;という状態も含めて考える。
dp[1,1,1]=1,dp[1,1,k]=0 (k=1,2,3)で、&lt;/p&gt;
&lt;p&gt;dp[i,j,1]=dp[i-1,j,1]+dp[i-1,j,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,2]=dp[i,-1j,2]+dp[i,j-1,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,3]=dp[i-1,j-1,3]+dp[i-1,j-1,4]&lt;/p&gt;
&lt;p&gt;dp[i,j,4]=dp[i-1,j,1]+dp[i,j-1,2]+dp[i-1,j-1,3] + dp[i-1,j,4]+dp[i,j-1,4]+dp[i-1,j-1,4]&lt;/p&gt;
&lt;p&gt;最後に(h,w)で着地する必要があるので、dp[h,w,4]が答えである。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/submissions/32114608&#34;&gt;https://atcoder.jp/contests/abc183/submissions/32114608&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 130 C - Rectangle Cutting</title>
      <link>https://matsueushi.github.io/atcoder/abc130-c/</link>
      <pubDate>Mon, 30 May 2022 21:40:55 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc130-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc130/tasks/abc130_c&#34;&gt;https://atcoder.jp/contests/abc130/tasks/abc130_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;長方形の対角線の交点をCとする。C=(x,y)ならどのように切っても長方形の面積を二等分できる。
そうでない場合はCと(x,y)を結ぶと二等分できる。
よって最初の答えは(x,y)の位置に関係なく長方形の面積の半分。最適な切り方が複数あるかは、C=(x,y)であるかどうか。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc130/submissions/32113015&#34;&gt;https://atcoder.jp/contests/abc130/submissions/32113015&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder DISCO presents ディスカバリーチャンネル コードコンテスト2020 予選 C - Strawberry Cakes</title>
      <link>https://matsueushi.github.io/atcoder/ddcc2020-qual-c/</link>
      <pubDate>Sat, 28 May 2022 19:55:21 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/ddcc2020-qual-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_c&#34;&gt;https://atcoder.jp/contests/ddcc2020-qual/tasks/ddcc2020_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各行に一つ以上イチゴが乗っている場合、行ごとに分割すれば目的が達成できる。
ある行に注目したときに、&lt;/p&gt;
&lt;p&gt;|🍓|　|　|🍓|　|　|&lt;/p&gt;
&lt;p&gt;であれば&lt;/p&gt;
&lt;p&gt;|1|2|2|2|2|2|&lt;/p&gt;
&lt;p&gt;のような帯に切り分ける。これを繰り返していくとイチゴが乗っていない行以外は、
行だけで注目するとイチゴが一つだけ乗った長方形のケーキに分かれる。
後はイチゴが1つも乗っていない行の切り方をイチゴが乗っている上の行か下の行に合わせて長方形になるようにする。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/ddcc2020-qual/submissions/31996005&#34;&gt;https://atcoder.jp/contests/ddcc2020-qual/submissions/31996005&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 137 D - Summer Vacation</title>
      <link>https://matsueushi.github.io/atcoder/abc137-d/</link>
      <pubDate>Thu, 26 May 2022 23:47:34 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc137-d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc137/tasks/abc137_d&#34;&gt;https://atcoder.jp/contests/abc137/tasks/abc137_d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;後ろから貪欲法で解ける気がする。
M-1日目を考えると、 残っている仕事のうち、
Ai=1を満たす仕事で報酬Biが最大となるものを請けるとして良いことがわかる。&lt;/p&gt;
&lt;p&gt;必要であれば受けた仕事の順番を入れ替えて、
M-1日目にする仕事は、全てのN件の日雇いバイトの中でAi=1を満たし報酬Biが最大となる仕事である、とできる。&lt;/p&gt;
&lt;p&gt;次にM-2日目を考えると、できる仕事はAi=1,2である仕事。Ai=1,Biが最大となる仕事は最終日にやることが決まっているので、
M-1日目と同様の考察により、それを除いた仕事のうち報酬が最大となるものを働けば良い。&lt;/p&gt;
&lt;p&gt;以下繰り返す。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc137/submissions/31967629&#34;&gt;https://atcoder.jp/contests/abc137/submissions/31967629&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 117 C - Streamline</title>
      <link>https://matsueushi.github.io/atcoder/abc117-c/</link>
      <pubDate>Wed, 25 May 2022 23:28:21 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc117-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc117/tasks/abc117_c&#34;&gt;https://atcoder.jp/contests/abc117/tasks/abc117_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数直線上に地点X_iを配置して、コマが移動した位置を塗りつぶすことを考える。&lt;/p&gt;
&lt;p&gt;移動回数を最小化したいので、塗りつぶす面積を最小化することを考える。&lt;/p&gt;
&lt;p&gt;X_1, &amp;hellip;, X_M によって M-1 個の区間が作られる。&lt;/p&gt;
&lt;p&gt;N=1だったら全ての区間をぬりぶさないとM個の地点全てに到達できない。
N=2だったら一つの区間は塗りつぶさずにスキップできる。
このように考えると、最大N-1個の区間は塗りつぶさずにスキップ可能であることがわかる。
よって、塗りつぶさないといけない区間はmax(0, M-N)個。&lt;/p&gt;
&lt;p&gt;区間の長さをソートし、短い順にmax(0, M-N)個の区間の長さの合計を求めると答えになる。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc117/submissions/31965997&#34;&gt;https://atcoder.jp/contests/abc117/submissions/31965997&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder みんなのプロコン2019 C - When I hit my pocket...</title>
      <link>https://matsueushi.github.io/atcoder/yahoo-procon2019-c/</link>
      <pubDate>Wed, 25 May 2022 23:05:47 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/yahoo-procon2019-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_c&#34;&gt;https://atcoder.jp/contests/yahoo-procon2019-qual/tasks/yahoo_procon2019_qual_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;円は残しておいても最終的なビスケットの枚数の最大値には寄与しない。また、使い道はビスケットB枚に交換することのみ。&lt;/p&gt;
&lt;p&gt;よって、Kアクション与えられた際、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1アクション使って、ビスケットを1枚増やす&lt;/li&gt;
&lt;li&gt;2アクション使って、ビスケットA枚をビスケットB枚に交換する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この二つの選択の組み合わせでビスケットの枚数を最大化する、という問題に帰着される。&lt;/p&gt;
&lt;p&gt;一つ目の行動を二回繰り返すとビスケットが2枚増える、ということは B&amp;gt;A+2でないと二つ目の行動をする意味がない。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B&amp;gt;A+2であったら二つ目の行動の方が効率が良いので、一つ目の行動でビスケットをA枚まで増やした後二つ目の行動を繰り返し、アクションが最後に1残ったら最後にもう一枚増やす&lt;/li&gt;
&lt;li&gt;B≤A+2だったら一つ目の行動を連打&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;で良い。後はkとaの大小関係に注意すればOK&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/31952356&#34;&gt;https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/31952356&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 154 E - Almost Everywhere Zero</title>
      <link>https://matsueushi.github.io/atcoder/abc154-e/</link>
      <pubDate>Wed, 25 May 2022 21:30:34 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc154-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc154/tasks/abc154_e&#34;&gt;https://atcoder.jp/contests/abc154/tasks/abc154_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;\(N\) の上 \(i\) 桁をつなげた数を \(N(i)\) とする。
\(N\) の上から \(i\) 桁目を \(N_i\) とする。\(N\) の桁数を \(l\) とする。&lt;/p&gt;
&lt;p&gt;\(dp[i,k,0] = \{ n \in \mathbb{Z} \mid  n &amp;lt; N(i) ,n の 0 でない数字の数が k \}\)
\(dp[i,k,1] = \{ n \in \mathbb{Z} \mid  n = N(i) ,n の 0 でない数字の数が k \}\)
とすると、求めたいのは \(dp[l,K,0] + dp[l,K,1]\) である。&lt;/p&gt;
&lt;p&gt;\(dp[i,0,0]=1, \) (0 に対応)&lt;/p&gt;
&lt;p&gt;\(dp[1,1,0] = N_1-1,\) (1,&amp;hellip;,N1- 1に対応)&lt;/p&gt;
&lt;p&gt;\(dp[1,k,0]= 0 (k \ge 2),\)&lt;/p&gt;
&lt;p&gt;\(dp[1,k,1] = 1,\)&lt;/p&gt;
&lt;p&gt;遷移を考えると&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,0] = dp[i,k,0]+9\cdot dp[i,k-1,0] (k \ge 1, N_{i+1}=0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,0] = dp[i,k,0]+9\cdot dp[i,k-1,0]+dp[i,k,1]+(N_{i+1}-1)dp[i,k-1,1] (k \ge 1, N_{i+1}\neq 0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,1] = dp[i,k,1] (N_{i+1} = 0),\)&lt;/p&gt;
&lt;p&gt;\(dp[i+1,k,1] = dp[i,k-1,1](N_{i+1} \neq 0),\)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc154/submissions/31951620&#34;&gt;https://atcoder.jp/contests/abc154/submissions/31951620&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;調べてみたらこういうものを桁DPというらしい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考
&lt;a href=&#34;https://algo-logic.info/digit-dp/&#34;&gt;桁DP(Digit DP) を考え方から問題例まで徹底解説！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 135 C - City Savers</title>
      <link>https://matsueushi.github.io/atcoder/abc135-c/</link>
      <pubDate>Wed, 25 May 2022 21:19:09 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc135-c/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc135/tasks/abc135_c&#34;&gt;https://atcoder.jp/contests/abc135/tasks/abc135_c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;勇者が倒せるモンスターの数を無駄にしたくないので、
他の勇者が倒せるモンスターよりも自分しか倒せないモンスターを優先して倒すようにする。&lt;/p&gt;
&lt;p&gt;1番目の街のモンスターは1番目の勇者しか倒せないので、1番目の勇者は優先的に1番目の街のモンスターを倒し、
余力があれば2番の街のモンスターを倒す。
2番目の勇者は残っている2番目の街ののモンスターから倒す……
と順々に考えれば良い&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc135/submissions/31950249&#34;&gt;https://atcoder.jp/contests/abc135/submissions/31950249&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderで緑色になった</title>
      <link>https://matsueushi.github.io/atcoder/green/</link>
      <pubDate>Sun, 15 May 2022 21:55:31 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/green/</guid>
      <description>&lt;p&gt;4月頭からAtCoder Beginner Contestに出ていたのですが、緑色になりました。
&lt;a href=&#34;https://atcoder.jp/users/matsueushi&#34;&gt;https://atcoder.jp/users/matsueushi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;蟻本を読みながら「競プロ典型90問」を9割ぐらい解答を見ながら解いて、その後はABCの過去問をA-D問題を中心に解いていました。
D問題で時間がかかってしまうことが多いので、&lt;a href=&#34;https://kenkoooo.com/atcoder/#/training/Boot%20camp%20for%20Beginners&#34;&gt;AtCoder Problems&lt;/a&gt; の「Boot camp for Beginners」を解きまくろうと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoder ABC 250 E - Prefix Equality</title>
      <link>https://matsueushi.github.io/atcoder/abc250-e/</link>
      <pubDate>Mon, 09 May 2022 21:47:26 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/abc250-e/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc250/tasks/abc250_e&#34;&gt;https://atcoder.jp/contests/abc250/tasks/abc250_e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンテスト中は解けそうで解けなかったが、シンプルな方法で解けることにあとから気づいて悔やまれた。&lt;/p&gt;
&lt;p&gt;\(S_i= \{a_1, \ldots, a_i\}, T_i=\{b_i, \ldots, b_i \} \)とおくと、\( S_1 \subseteq S_2 \subseteq \cdots \subseteq S_n, T_1 \subseteq T_2 \subseteq \cdots \subseteq T_n\)となる。&lt;/p&gt;
&lt;p&gt;\(f_i= \max \{j \mid T_j \subseteq S_i \}, g_i= \max \{j \mid S_j \subseteq T_i \} \) を計算する。例えば\(f_i\)まで計算した後に\(f_{i+1}\)を計算するときは、\(b_{f_i+1}, b_{f_i+2}, \ldots , b_j\) が \(S_{i+1}\) に含まれているかをチェックしていき含まれなくなったら\(f_{i+1}=j-1\) とすれば良い。&lt;/p&gt;
&lt;p&gt;後は\(S_i = T_j \Leftrightarrow S_i \subseteq T_j, T_j \subseteq S_i \Leftrightarrow i \le g_j, j \le f_i\)でクエリを判定すれば良い。&lt;/p&gt;
&lt;p&gt;(Julia, 564 ms)
&lt;a href=&#34;https://atcoder.jp/contests/abc250/submissions/31571164&#34;&gt;https://atcoder.jp/contests/abc250/submissions/31571164&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JuliaでAtCoderに挑戦</title>
      <link>https://matsueushi.github.io/atcoder/julia-atcoder/</link>
      <pubDate>Fri, 04 Feb 2022 23:09:38 +0900</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/julia-atcoder/</guid>
      <description>&lt;p&gt;去年は色々と忙しくじっくり勉強する時間がなかったので、リハビリを兼ねて競技プログラミングの問題をJuliaで挑戦してみることにします。&lt;/p&gt;
&lt;p&gt;ひとまず、AtCoderの&lt;a href=&#34;https://atcoder.jp/contests/typical90&#34;&gt;競プロ典型 90 問&lt;/a&gt;を解いて行く予定です。
ジャッジ時にJITコンパイルが走って200~300ms程度消費してしまいますが、幸い今のところTLEでどう頑張っても通せない問題はなかったです。&lt;/p&gt;
&lt;p&gt;下に解答を記録していこうと思います。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/matsueushi/CompetitiveProgramming&#34;&gt;https://github.com/matsueushi/CompetitiveProgramming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;さてはて、いつまで続くやら。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2022/6/7 追記 (随時更新)&lt;/p&gt;
&lt;p&gt;ちょっとしたテクニック&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入力&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parseint() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parse(&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;, readline())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parseints() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parse&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;, split(readline()))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; parsepoints(n&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    xs, ys &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;, n), zeros(&lt;span style=&#34;color:#66d9ef&#34;&gt;Int&lt;/span&gt;, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        xs[i], ys[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parseints()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    xs, ys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; parsestrings(n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ss &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Vector&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;String&lt;/span&gt;}(undef, n)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;n
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ss[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; readline()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ss
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;このようなテンプレートを作っておくと便利&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パッケージのバージョンを確認する
ローカルの実行環境をジャッジと合わせておかないと、予期しないエラーが起こる可能性あり。
コードテストで&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Pkg
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;println(Pkg&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status())
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;を実行すると使われているパッケージのバージョンが分かります。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Status &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;~/.julia/environments/v1.4/Project.toml&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;864edb3b&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; DataStructures v0.17.11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;27ebfcd6&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; Primes v0.4.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nothing
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;StringからVector{Char}への変換&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Vector&lt;/span&gt;{&lt;span style=&#34;color:#66d9ef&#34;&gt;Char&lt;/span&gt;}(s)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;負の数の剰余&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-julia&#34; data-lang=&#34;julia&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;julia&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; mod(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>AtCoderメモ書き</title>
      <link>https://matsueushi.github.io/atcoder/memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://matsueushi.github.io/atcoder/memo/</guid>
      <description>&lt;p&gt;自分用のメモです。&lt;/p&gt;
&lt;h3 id=&#34;waの時に確認すべきこと&#34;&gt;WAの時に確認すべきこと&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;問題文は正しく読めているか？&lt;/li&gt;
&lt;li&gt;オーバーフローしていないか？&lt;/li&gt;
&lt;li&gt;998244353や10^9+7で割った余りを求めるタイプの場合、余りを取っているか？
負の値を足している時、&lt;code&gt;res = (res % P + P) % P&lt;/code&gt;のようなケアをしているか？&lt;/li&gt;
&lt;li&gt;二分探索をしている時、最小値、最大値に到達できるか？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;探索&#34;&gt;探索&lt;/h2&gt;
&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc138/tasks/abc138_d&#34;&gt;ABC 138 D - Ki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc240/tasks/abc240_e&#34;&gt;E - Ranges on Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc213/tasks/abc213_d&#34;&gt;D - Takahashi Tour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;木を辿る&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc220/tasks/abc220_f&#34;&gt;ABC 220 F - Distance Sums 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bfs&#34;&gt;BFS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc151/tasks/abc151_d&#34;&gt;ABC 151 D - Maze Master&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc088/tasks/abc088_d&#34;&gt;ABC 088 D - Grid Repainting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bit全探索&#34;&gt;Bit全探索&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc147/tasks/abc147_c&#34;&gt;ABC 147 C - HonestOrUnkind2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dp&#34;&gt;DP&lt;/h2&gt;
&lt;h3 id=&#34;1次元&#34;&gt;1次元&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc034/tasks/agc034_a&#34;&gt;AGC 034 A - Kenken Race&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2次元&#34;&gt;2次元&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc183/tasks/abc183_e&#34;&gt;ABC 183 E - Queen on Grid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/agc043/tasks/agc043_a&#34;&gt;AGC 043 A - Range Flip Find Route&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;桁dp&#34;&gt;桁DP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc154/tasks/abc154_e&#34;&gt;ABC 154 E Almost Everywhere Zero&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;タイリング敷き詰め&#34;&gt;タイリング/敷き詰め&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;蟻本 p.p. 177 ドミノ敷き詰め&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_aw&#34;&gt;アルゴリズムと数学　演習問題集 057 - Domino Tiling&lt;/a&gt; 紛らわしい例&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ナップザック問題&#34;&gt;ナップザック問題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc153/tasks/abc153_e&#34;&gt;ABC 153 E - Crested Ibis vs Monster&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ぐるぐる遷移していくやつ&#34;&gt;ぐるぐる遷移していくやつ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/abc167_d&#34;&gt;アルゴリズムと数学　演習問題集 062 - Teleporter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区間スケジュール問題&#34;&gt;区間スケジュール問題&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://algo-method.com/tasks/363/editorial&#34;&gt;区間スケジューリング問題 | アルゴ式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/keyence2020/tasks/keyence2020_b&#34;&gt;キーエンス2020 B Robot Arms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_bn&#34;&gt;アルゴリズムと数学　演習問題集 082 - Interval Scheduling Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数列整数&#34;&gt;数列/整数&lt;/h2&gt;
&lt;h3 id=&#34;約数&#34;&gt;約数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc134/tasks/abc134_d&#34;&gt;ABC 134 D - Preparing Boxes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;素数&#34;&gt;素数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc084/tasks/abc084_d&#34;&gt;ABC 084 D - 2017-like Number&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;フィボナッチ数列漸化式&#34;&gt;フィボナッチ数列/漸化式&lt;/h3&gt;
&lt;p&gt;行列演算&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_ap&#34;&gt;アルゴリズムと数学　演習問題集 049 Fibonacci Easy (mod 1000000007)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_at&#34;&gt;アルゴリズムと数学　演習問題集 054 - Fibonacci Hard (mod 1000000000)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_au&#34;&gt;アルゴリズムと数学　演習問題集 055 - Recurrence Formula 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_av&#34;&gt;アルゴリズムと数学　演習問題集 056 - Recurrence Formula 1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数列の連続する項目の差の絶対値に注目&#34;&gt;数列の連続する項目の差の絶対値に注目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc253/tasks/abc253_e&#34;&gt;ABC 253 E Distance Sequence&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;幾何&#34;&gt;幾何&lt;/h2&gt;
&lt;h3 id=&#34;三角形&#34;&gt;三角形&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc143/tasks/abc143_d&#34;&gt;ABC 143 D - Triangles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;円の交点&#34;&gt;円の交点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_ag&#34;&gt;アルゴリズムと数学　演習問題集 035 - Two Circles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;凸性&#34;&gt;凸性&lt;/h3&gt;
&lt;p&gt;外積で判定できる&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://perogram.hateblo.jp/entry/2020/09/25/035159&#34;&gt;外積で凸性判定 - perogram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc266/tasks/abc266_c&#34;&gt;ABC266 C - Convex Quadrilateral&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;グラフ&#34;&gt;グラフ&lt;/h2&gt;
&lt;h3 id=&#34;二部グラフ判定&#34;&gt;二部グラフ判定&lt;/h3&gt;
&lt;p&gt;DFS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/math_and_algorithm_ao&#34;&gt;アルゴリズムと数学　演習問題集 047 - Bipartite Graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ダイクストラ&#34;&gt;ダイクストラ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc252/tasks/abc252_e&#34;&gt;ABC 252 E Road Reduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ワーシャルフロイド&#34;&gt;ワーシャルフロイド&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc079/tasks/abc079_d&#34;&gt;ABC 079 D - Wall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;橋&#34;&gt;橋&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nupioca.hatenadiary.jp/entry/2013/11/03/200006&#34;&gt;橋（bridge）検出アルゴリズム - nupiocaの日記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc075/tasks/abc075_c&#34;&gt;ABC 075 C - Bridge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;閉路&#34;&gt;閉路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc266/tasks/abc266_f&#34;&gt;ABC 266 F - Well-defined Path Queries on a Namori&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lca&#34;&gt;LCA&lt;/h3&gt;
&lt;p&gt;蟻本 pp.292&lt;/p&gt;
&lt;p&gt;\(d(u,v)=depth(u)+depth(v)-2depth(lca(u,v))\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/e869120/status/1391218516129312768&#34;&gt;競プロ典型90問 35日目解説@e869120&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;セグメント木&#34;&gt;セグメント木&lt;/h2&gt;
&lt;h3 id=&#34;fenwick-tree&#34;&gt;Fenwick Tree&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc253/tasks/abc253_f&#34;&gt;ABC 254 F - Operations on a Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通常のセグメント木&#34;&gt;通常のセグメント木&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc185/tasks/abc185_f&#34;&gt;ABC 165 F - Range Xor Query&lt;/a&gt; XOR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区間和&#34;&gt;区間和&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://imoz.jp/algorithms/imos_method.html&#34;&gt;いもす法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;アルゴリズムと数学　演習問題集 041&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;その他&#34;&gt;その他&lt;/h2&gt;
&lt;h3 id=&#34;括弧&#34;&gt;括弧&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc064/tasks/abc064_d&#34;&gt;ABC 064 D - Insertion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;マンハッタン距離&#34;&gt;マンハッタン距離&lt;/h3&gt;
&lt;p&gt;45度回転が有用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc178/tasks/abc178_e&#34;&gt;ABC E - Dist Max&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;チェスのナイト&#34;&gt;チェスのナイト&lt;/h3&gt;
&lt;p&gt;斜めに動くとわかりづらいので、座標変換を行う。
$$
\begin{aligned}
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right) =
\left(
\begin{matrix}
1 &amp;amp; 2 \\
2 &amp;amp; 1
\end{matrix}
\right)
\left(
\begin{matrix}
s \\
t
\end{matrix}
\right)
\end{aligned}
$$
だから、逆変換
$$
\begin{aligned}
\left(
\begin{matrix}
s \\
t
\end{matrix}
\right) =
-\frac{1}{3}
\left(
\begin{matrix}
1 &amp;amp; -2 \\
-2 &amp;amp; 1
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\end{aligned}
$$
を考えることにより縦横の単純な移動に変換する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蟻本 pp.353 Endless Knight&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://atcoder.jp/contests/math-and-algorithm/tasks/abc145_d&#34;&gt;アルゴリズムと数学　演習問題集 052 - Knight&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>